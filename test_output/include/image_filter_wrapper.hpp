// Generated by RoboDSL - DO NOT EDIT

#ifndef IMAGE_FILTER_KERNEL_HPP
#define IMAGE_FILTER_KERNEL_HPP

#include <cuda_runtime.h>
#include <cstdint>
#include <vector>
#include <memory>

// Forward declarations for CUDA types
struct cudaStream_t;

namespace robodsl {

/**
 * @brief CUDA kernel wrapper class for image_filter
 * 
 * This class provides a C++ interface to CUDA kernels, handling memory management
 * and kernel launches. It's designed to work with the ROS2 node lifecycle.
 */
class image_filterKernel {
public:
    /**
     * @brief Construct a new image_filter Kernel object
     * 
     * @param stream CUDA stream to use for kernel execution (nullptr for default stream)
     */
    explicit image_filterKernel(cudaStream_t* stream = nullptr);
    
    /**
     * @brief Destroy the image_filter Kernel object
     * 
     * Frees all allocated device memory.
     */
    ~image_filterKernel();
    
    // Delete copy constructor and assignment operator
    image_filterKernel(const image_filterKernel&) = delete;
    image_filterKernel& operator=(const image_filterKernel&) = delete;
    
    /**
     * @brief Initialize the kernel with input data
     * 
     * @param input Input data to process
     * @return true if initialization was successful, false otherwise
     */
    bool initialize(const std::vector<unsigned char*>& input);
    
    /**
     * @brief Process the input data using the CUDA kernel
     * 
     * @param parameters Kernel parameters
     * @return std::vector<unsigned char*> Processed output data
     */
    std::vector<unsigned char*> process(const KernelParameters& parameters);
    
    /**
     * @brief Get the last error message, if any
     * 
     * @return std::string The last error message, or an empty string if no error
     */
    std::string getLastError() const { return last_error_; }
    
    /**
     * @brief Check if the kernel was initialized successfully
     * 
     * @return true if initialized, false otherwise
     */
    bool isInitialized() const { return initialized_; }
    
private:
    // Device memory pointers
    unsigned char** d_input_image_{nullptr};  //!< Device memory for input_image
    float** d_kernel_{nullptr};  //!< Device memory for kernel
    unsigned char** d_output_image_{nullptr};  //!< Device memory for output_image
    
    cudaStream_t* stream_{nullptr};  //!< CUDA stream for async operations
    bool initialized_{false};        //!< Whether the kernel is properly initialized
    std::string last_error_;         //!< Last error message, if any
    
    // CUDA kernel launch configuration
    static constexpr int kBlockSize = 32;  //!< Threads per block
    
    /**
     * @brief Check for CUDA errors and update last_error_ if needed
     * 
     * @param status CUDA status to check
     * @param context Context string for error messages
     * @return true if no error, false otherwise
     */
    bool checkCudaError(cudaError_t status, const std::string& context);
    
    /**
     * @brief Allocate device memory
     * 
     * @return true if allocation was successful, false otherwise
     */
    bool allocateDeviceMemory();
    
    /**
     * @brief Free device memory
     */
    void freeDeviceMemory();
};

} // namespace robodsl


#endif // IMAGE_FILTER_KERNEL_HPP

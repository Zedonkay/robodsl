// Example demonstrating raw C++ code blocks in RoboDSL

include <iostream>
include <vector>

// Global raw C++ code - gets passed through as-is to a separate .cpp file
cpp: {
    namespace global_utils {
        template<typename T>
        class VectorProcessor {
        public:
            static std::vector<T> process(const std::vector<T>& input) {
                std::vector<T> result;
                result.reserve(input.size());
                for (const auto& item : input) {
                    result.push_back(item * 2);
                }
                return result;
            }
        };
        
        // Utility function for logging
        void log_message(const std::string& message) {
            std::cout << "[Global Utils] " << message << std::endl;
        }
    }
}

// Another global C++ block
cpp: {
    namespace math_helpers {
        double calculate_average(const std::vector<double>& values) {
            if (values.empty()) return 0.0;
            double sum = 0.0;
            for (double value : values) {
                sum += value;
            }
            return sum / values.size();
        }
    }
}

// Node with raw C++ code inside
node data_processor {
    parameter int buffer_size = 1024
    parameter double threshold = 0.5
    
    publisher /processed_data: "std_msgs/msg/Float64MultiArray"
    subscriber /raw_data: "std_msgs/msg/Float64MultiArray"
    
    // Raw C++ code inside the node - gets included in the generated header and source
    cpp: {
        class DataProcessorHelper {
        private:
            int buffer_size_;
            double threshold_;
            
        public:
            DataProcessorHelper(int buffer_size, double threshold)
                : buffer_size_(buffer_size), threshold_(threshold) {}
            
            std::vector<double> process_data(const std::vector<double>& input) {
                std::vector<double> result;
                result.reserve(input.size());
                
                for (double value : input) {
                    if (value > threshold_) {
                        result.push_back(value * 2.0);
                    } else {
                        result.push_back(value);
                    }
                }
                
                return result;
            }
            
            bool validate_data(const std::vector<double>& data) {
                return data.size() <= buffer_size_;
            }
        };
    }
    
    // Another C++ block inside the node
    cpp: {
        // Constants for the node
        constexpr int MAX_RETRIES = 3;
        constexpr double EPSILON = 1e-6;
        
        // Helper function for error handling
        void handle_processing_error(const std::string& error_msg) {
            std::cerr << "Data processing error: " << error_msg << std::endl;
        }
    }
}

// Another node without raw C++ code
node simple_publisher {
    parameter string message = "Hello World"
    
    publisher /greeting: "std_msgs/msg/String"
    timer heartbeat: 1.0
} 
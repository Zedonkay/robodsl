// Generated by RoboDSL - DO NOT EDIT

#ifndef MAIN_NODE_NODE_HPP
#define MAIN_NODE_NODE_HPP

// Standard includes
#include <memory>
#include <string>
#include <vector>

// ROS2 includes
#include <rclcpp/rclcpp.hpp>
#include <rclcpp_lifecycle/lifecycle_node.hpp>
#include <rclcpp_lifecycle/lifecycle_publisher.hpp>
#include <rclcpp_lifecycle/lifecycle_node_interface.hpp>
#include <rclcpp_components/register_node_macro.hpp>

// Message includes
#include <ImageProcessing.hpp>
#include <sensor_msgs/msg/Image.hpp>
#include <DetectionResult.hpp>
#include <geometry_msgs/msg/PoseStamped.hpp>
#include <std_msgs/msg/String.hpp>


// Global C++ code blocks (passed through as-is)

    // Additional C++ code that gets included in the generated files
    namespace robot_utils {
        // Utility functions
        template<typename T>
        T clamp(T value, T min, T max) {
            return std::max(min, std::min(max, value));
        }
        
        double radians_to_degrees(double radians) {
            return radians * 180.0 / M_PI;
        }
        
        double degrees_to_radians(double degrees) {
            return degrees * M_PI / 180.0;
        }
    }


namespace robodsl {

// CUDA kernel parameter structs
// Struct for vector_add kernel parameters
struct Vector_addParameters {
    float* a;
    float* b;
    int size;
    float* c;
};
// Struct for matrix_multiply kernel parameters
struct Matrix_multiplyParameters {
    float* a;
    float* b;
    int m;
    int n;
    int k;
    float* c;
};
// Struct for image_filter kernel parameters
struct Image_filterParameters {
    uchar* input_image;
    int width;
    int height;
    uchar* output_image;
};

class Main_nodeNode : public rclcpp_lifecycle::LifecycleNode {
public:
    // Referenced global CUDA kernels
    /**
     * Referenced global CUDA kernels:
     *      *   - vector_add
     *      *   - matrix_multiply
     *      *   - image_filter
     *      */
    explicit Main_nodeNode(const rclcpp::NodeOptions& options = rclcpp::NodeOptions());
    ~Main_nodeNode() override;

    // Lifecycle node interface
    rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn 
    on_configure(const rclcpp_lifecycle::State& previous_state) override;
    
    rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn 
    on_activate(const rclcpp_lifecycle::State& previous_state) override;
    
    rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn 
    on_deactivate(const rclcpp_lifecycle::State& previous_state) override;
    
    rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn 
    on_cleanup(const rclcpp_lifecycle::State& previous_state) override;
    
    rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn 
    on_shutdown(const rclcpp_lifecycle::State& previous_state) override;
    
    rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn 
    on_error(const rclcpp_lifecycle::State& previous_state) override;

    // Timer callbacks
    void on_main_timer();
    void on_processing_timer();

    // Subscriber callbacks
    void on_image_raw(const sensor_msgs::msg::Image::ConstSharedPtr msg);
    void on_goal_pose(const geometry_msgs::msg::PoseStamped::ConstSharedPtr msg);

    // Service callbacks
    void on_process_image(
        const std::shared_ptr<ImageProcessing::Request> request,
        std::shared_ptr<ImageProcessing::Response> response);

    // Action server callbacks

    // CUDA kernels
    /**
     * @brief Process data using CUDA acceleration
     * @param input Input data to process
     * @param parameters Processing parameters
     * @return Processed output data
     * @note This is a virtual method that can be overridden by derived classes
     * to provide custom CUDA-accelerated processing. The default implementation
     * will return an empty vector if not overridden.
     */
    virtual std::vector<float> processWithCuda(
        const std::vector<float>& input,
        const CudaParams& parameters);
    
    /**
     * @brief Initialize CUDA resources
     * @return true if initialization was successful, false otherwise
     * @note Override this method to perform custom CUDA initialization.
     * Call the base class implementation if you override this method.
     */
    virtual bool initializeCuda();
    
    /**
     * @brief Clean up CUDA resources
     * @note Override this method to perform custom CUDA cleanup.
     * Call the base class implementation if you override this method.
     */
    virtual void cleanupCuda();
    
    // Individual CUDA kernel declarations
    /**
     * @brief Process data using CUDA kernel: vector_add
     * @note This method provides a C++ interface to the vector_add CUDA kernel.
     * The actual CUDA kernel implementation should be provided in a .cu file.
     */
    virtual void vector_add(float* a, float* b, int size, float* c);
    /**
     * @brief Process data using CUDA kernel: matrix_multiply
     * @note This method provides a C++ interface to the matrix_multiply CUDA kernel.
     * The actual CUDA kernel implementation should be provided in a .cu file.
     */
    virtual void matrix_multiply(float* a, float* b, int m, int n, int k, float* c);
    /**
     * @brief Process data using CUDA kernel: image_filter
     * @note This method provides a C++ interface to the image_filter CUDA kernel.
     * The actual CUDA kernel implementation should be provided in a .cu file.
     */
    virtual void image_filter(uchar* input_image, int width, int height, uchar* output_image);
    // NOTE: This node uses Thrust algorithms in at least one CUDA kernel.
    #include <thrust/device_vector.h>
    #include <thrust/transform.h>
    #include <thrust/functional.h>

    // User-defined C++ methods
    /**
     * @brief on_timer_callback - User-defined C++ method
     * @param current_time Input parameter of type rclcpp::Time     */
    void on_timer_callback(
rclcpp::Time current_time    );
    /**
     * @brief on_processing_callback - User-defined C++ method
     * @param code Input parameter of type void     */
    void on_processing_callback(
void code    );
    /**
     * @brief process_image - User-defined C++ method
     * @param image_msg Input parameter of type const sensor_msgs::msg::Image::SharedPtr     * @param detections Output parameter of type std::vector<DetectionResult>&     */
    void process_image(
const sensor_msgs::msg::Image::SharedPtr image_msg, std::vector<DetectionResult>&& detections    );
    /**
     * @brief process_image_gpu - User-defined C++ method
     * @param image Input parameter of type const cv::Mat&     * @param detections Output parameter of type std::vector<DetectionResult>&     */
    void process_image_gpu(
const cv::Mat& image, std::vector<DetectionResult>&& detections    );
    /**
     * @brief run_detection_inference - User-defined C++ method
     * @param image Input parameter of type const cv::Mat&     * @param detections Output parameter of type std::vector<DetectionResult>&     */
    void run_detection_inference(
const cv::Mat& image, std::vector<DetectionResult>&& detections    );

    // Raw C++ code blocks (passed through as-is)

private:
    // ROS2 publishers
    std::shared_ptr<rclcpp_lifecycle::LifecyclePublisher<std_msgs::msg::String>> chatter_pub_;
    std::shared_ptr<rclcpp_lifecycle::LifecyclePublisher<sensor_msgs::msg::Image>> image_processed_pub_;
    std::shared_ptr<rclcpp_lifecycle::LifecyclePublisher<DetectionResult>> detections_pub_;

    // ROS2 subscribers
    rclcpp::Subscription<sensor_msgs::msg::Image>::SharedPtr image_raw_sub_;
    rclcpp::Subscription<geometry_msgs::msg::PoseStamped>::SharedPtr goal_pose_sub_;

    // ROS2 services
    rclcpp::Service<ImageProcessing>::SharedPtr process_image_srv_;

    // ROS2 action servers

    // ROS2 timers
    rclcpp::TimerBase::SharedPtr main_timer_timer_;
    rclcpp::TimerBase::SharedPtr processing_timer_timer_;

    // Parameters
    int count_;
    double rate_;
    string name_;
    bool enabled_;
    list array_coords_;
    dict dict_config_;

    // CUDA members
    //  members
    float* a_;
    float* b_;
    int size_;
    float* c_;
    //  members
    float* a_;
    float* b_;
    int m_;
    int n_;
    int k_;
    float* c_;
    //  members
    uchar* input_image_;
    int width_;
    int height_;
    uchar* output_image_;

    // Private methods
    void init_parameters();
    void init_publishers();
    void init_subscribers();
    void init_services();
    void init_action_servers();
    void init_timers();
    void init_cuda();
};

} // namespace robodsl

// Register component
#include <rclcpp_components/register_node_macro.hpp>
RCLCPP_COMPONENTS_REGISTER_NODE(::robodsl::Main_nodeNode)

#endif // MAIN_NODE_NODE_HPP

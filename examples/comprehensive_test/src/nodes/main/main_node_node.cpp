// Generated by RoboDSL - DO NOT EDIT

#include "nodes/main/main_node_node.hpp"
#include <memory>
#include <vector>
#include <map>
#include <cmath>

// Global C++ code blocks (passed through as-is)

// Additional C++ code that gets included in the generated files
namespace robot_utils {
    // Utility functions
    template<typename T>
    T clamp(T value, T min, T max) {
        return std::max(min, std::min(max, value));
    }

    double radians_to_degrees(double radians) {
        return radians * 180.0 / M_PI;
    }

    double degrees_to_radians(double degrees) {
        return degrees * M_PI / 180.0;
    }
}


namespace robodsl {

Main_nodeNode::Main_nodeNode(const rclcpp::NodeOptions& options)
: rclcpp_lifecycle::LifecycleNode("main_node", options)
{
    // Initialize parameters
    this->declare_parameter<int>("count", 0);
    this->declare_parameter<double>("rate", 10.0);
    this->declare_parameter<std::string>("name", "robot");
    this->declare_parameter<bool>("enabled", true);
    this->declare_parameter<std::vector<double>>("array_coords", {1.0, 2.0, 3.0});
    this->declare_parameter<std::map<std::string, double>>("dict_config", {{"max_iterations", 100.0}, {"timeout", 5.0}, {"enabled", 1.0}});

    // Create publishers
    {
        rclcpp::QoS qos(10);
        qos.reliability(rclcpp::ReliabilityPolicy::Reliable);
        chatter_pub_ = this->create_publisher<std_msgs::msg::String>(
            "/chatter", qos);
    }
    {
        rclcpp::QoS qos(5);
        qos.reliability(rclcpp::ReliabilityPolicy::BestEffort);
        image_processed_pub_ = this->create_publisher<sensor_msgs::msg::Image>(
            "/image_processed", qos);
    }
    {
        rclcpp::QoS qos(20);
        qos.reliability(rclcpp::ReliabilityPolicy::Reliable);
        detections_pub_ = this->create_publisher<std_msgs::msg::String>(
            "/detections", qos);
    }

    // Create subscribers
    {
        rclcpp::QoS qos(5);
        qos.reliability(rclcpp::ReliabilityPolicy::BestEffort);
        auto callback = std::bind(
            &Main_nodeNode::on_image_raw, 
            this, 
            std::placeholders::_1
        );
        image_raw_sub_ = this->create_subscription<sensor_msgs::msg::Image>(
            "/camera/image_raw", 
            qos, 
            callback
        );
    }
    {
        rclcpp::QoS qos(10);
        qos.reliability(rclcpp::ReliabilityPolicy::Reliable);
        auto callback = std::bind(
            &Main_nodeNode::on_goal_pose, 
            this, 
            std::placeholders::_1
        );
        goal_pose_sub_ = this->create_subscription<geometry_msgs::msg::PoseStamped>(
            "/goal_pose", 
            qos, 
            callback
        );
    }

    // Create services with proper error handling
    {
        try {
            auto callback = [this](
                const std::shared_ptr<std_srvs::srv::SetBool::Request> request,
                std::shared_ptr<std_srvs::srv::SetBool::Response> response
            ) {
                try {
                    return this->on_process_image(request, response);
                } catch (const std::exception& e) {
                    RCLCPP_ERROR(this->get_logger(), 
                        "Exception in service callback on_process_image: %s", e.what());
                    response->success = false;
                    response->message = std::string("Service error: ") + e.what();
                } catch (...) {
                    RCLCPP_ERROR(this->get_logger(), 
                        "Unknown exception in service callback on_process_image");
                    response->success = false;
                    response->message = "Unknown service error";
                }
            };
            
            process_image_srv_ = this->create_service<std_srvs::srv::SetBool>(
                "/process_image", 
                callback
            );
            
            RCLCPP_INFO(this->get_logger(), 
                "Created service server: %s", "/process_image");
                
        } catch (const std::exception& e) {
            RCLCPP_ERROR(this->get_logger(), 
                "Failed to create service /process_image: %s", e.what());
            throw;
        }
    }
    
    // Initialize action servers
}

Main_nodeNode::~Main_nodeNode()
{
    // Clean up CUDA resources if enabled
    
    // Cleanup CUDA resources if needed
    // Cleanup  resources
    if (a_) {
        cudaFree(a_);
        a_ = nullptr;
    }
    if (b_) {
        cudaFree(b_);
        b_ = nullptr;
    }
    // size_ is not a pointer, no cleanup needed
    if (c_) {
        cudaFree(c_);
        c_ = nullptr;
    }
    // Cleanup  resources
    if (a_) {
        cudaFree(a_);
        a_ = nullptr;
    }
    if (b_) {
        cudaFree(b_);
        b_ = nullptr;
    }
    // m_ is not a pointer, no cleanup needed
    // n_ is not a pointer, no cleanup needed
    // k_ is not a pointer, no cleanup needed
    if (c_) {
        cudaFree(c_);
        c_ = nullptr;
    }
    // Cleanup  resources
    if (input_image_) {
        cudaFree(input_image_);
        input_image_ = nullptr;
    }
    // width_ is not a pointer, no cleanup needed
    // height_ is not a pointer, no cleanup needed
    if (output_image_) {
        cudaFree(output_image_);
        output_image_ = nullptr;
    }
}

// Lifecycle callbacks
rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
Main_nodeNode::on_configure(const rclcpp_lifecycle::State& previous_state)
{
    RCLCPP_INFO(
        this->get_logger(), 
        "Configuring from [%s] state...", 
        previous_state.label().c_str()
    );
    
    try {
        // Load and validate parameters
        {
            rclcpp::Parameter param;
            if (this->get_parameter("count", param)) {
                // Parameter loaded successfully
                RCLCPP_DEBUG(
                    this->get_logger(), 
                    "Loaded parameter '%s': %s", 
                    "count", 
                    param.value_to_string().c_str()
                );
                
                // Store the parameter value
                count_ = param.as_int();
            } else {
                RCLCPP_WARN(
                    this->get_logger(), 
                    "Failed to load parameter '%s', using default value", 
                    "count"
                );
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("rate", param)) {
                // Parameter loaded successfully
                RCLCPP_DEBUG(
                    this->get_logger(), 
                    "Loaded parameter '%s': %s", 
                    "rate", 
                    param.value_to_string().c_str()
                );
                
                // Store the parameter value
                rate_ = param.as_double();
            } else {
                RCLCPP_WARN(
                    this->get_logger(), 
                    "Failed to load parameter '%s', using default value", 
                    "rate"
                );
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("name", param)) {
                // Parameter loaded successfully
                RCLCPP_DEBUG(
                    this->get_logger(), 
                    "Loaded parameter '%s': %s", 
                    "name", 
                    param.value_to_string().c_str()
                );
                
                // Store the parameter value
                name_ = param.as_string();
            } else {
                RCLCPP_WARN(
                    this->get_logger(), 
                    "Failed to load parameter '%s', using default value", 
                    "name"
                );
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("enabled", param)) {
                // Parameter loaded successfully
                RCLCPP_DEBUG(
                    this->get_logger(), 
                    "Loaded parameter '%s': %s", 
                    "enabled", 
                    param.value_to_string().c_str()
                );
                
                // Store the parameter value
                enabled_ = param.as_bool();
            } else {
                RCLCPP_WARN(
                    this->get_logger(), 
                    "Failed to load parameter '%s', using default value", 
                    "enabled"
                );
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("array_coords", param)) {
                // Parameter loaded successfully
                RCLCPP_DEBUG(
                    this->get_logger(), 
                    "Loaded parameter '%s': %s", 
                    "array_coords", 
                    param.value_to_string().c_str()
                );
                
                // Store the parameter value
                array_coords_ = param.as_double_array();
            } else {
                RCLCPP_WARN(
                    this->get_logger(), 
                    "Failed to load parameter '%s', using default value", 
                    "array_coords"
                );
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("dict_config", param)) {
                // Parameter loaded successfully
                RCLCPP_DEBUG(
                    this->get_logger(), 
                    "Loaded parameter '%s': %s", 
                    "dict_config", 
                    param.value_to_string().c_str()
                );
                
                // Store the parameter value
                // Warning: Map parameters not supported in ROS2 - skipping dict_config
                RCLCPP_WARN(this->get_logger(), "Map parameter 'dict_config' not supported, using default");
            } else {
                RCLCPP_WARN(
                    this->get_logger(), 
                    "Failed to load parameter '%s', using default value", 
                    "dict_config"
                );
            }
        }
        
        // Initialize any resources needed before activation
        
        RCLCPP_INFO(this->get_logger(), "Configuration completed successfully");
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;
        
    } catch (const std::exception& e) {
        RCLCPP_ERROR(
            this->get_logger(), 
            "Configuration failed: %s", 
            e.what()
        );
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::FAILURE;
    } catch (...) {
        RCLCPP_ERROR(
            this->get_logger(), 
            "Unknown error during configuration"
        );
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::ERROR;
    }
}

rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
Main_nodeNode::on_activate(const rclcpp_lifecycle::State& previous_state)
{
    RCLCPP_INFO(
        this->get_logger(), 
        "Activating from [%s] state...", 
        previous_state.label().c_str()
    );
    
    try {
        // Activate publishers
        if (chatter_pub_) {
            try {
                auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<std_msgs::msg::String>>(chatter_pub_);
                if (pub) {
                    pub->on_activate();
                    RCLCPP_DEBUG(
                        this->get_logger(), 
                        "Activated publisher: %s", 
                        "/chatter"
                    );
                } else {
                    RCLCPP_WARN(
                        this->get_logger(), 
                        "Publisher '%s' is not a lifecycle publisher", 
                        "/chatter"
                    );
                }
            } catch (const std::exception& e) {
                RCLCPP_ERROR(
                    this->get_logger(), 
                    "Failed to activate publisher '%s': %s", 
                    "/chatter", 
                    e.what()
                );
                throw;
            }
        } else {
            RCLCPP_WARN(
                this->get_logger(), 
                "Publisher '%s' is null", 
                "/chatter"
            );
        }
        if (image_processed_pub_) {
            try {
                auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<sensor_msgs::msg::Image>>(image_processed_pub_);
                if (pub) {
                    pub->on_activate();
                    RCLCPP_DEBUG(
                        this->get_logger(), 
                        "Activated publisher: %s", 
                        "/image_processed"
                    );
                } else {
                    RCLCPP_WARN(
                        this->get_logger(), 
                        "Publisher '%s' is not a lifecycle publisher", 
                        "/image_processed"
                    );
                }
            } catch (const std::exception& e) {
                RCLCPP_ERROR(
                    this->get_logger(), 
                    "Failed to activate publisher '%s': %s", 
                    "/image_processed", 
                    e.what()
                );
                throw;
            }
        } else {
            RCLCPP_WARN(
                this->get_logger(), 
                "Publisher '%s' is null", 
                "/image_processed"
            );
        }
        if (detections_pub_) {
            try {
                auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<std_msgs::msg::String>>(detections_pub_);
                if (pub) {
                    pub->on_activate();
                    RCLCPP_DEBUG(
                        this->get_logger(), 
                        "Activated publisher: %s", 
                        "/detections"
                    );
                } else {
                    RCLCPP_WARN(
                        this->get_logger(), 
                        "Publisher '%s' is not a lifecycle publisher", 
                        "/detections"
                    );
                }
            } catch (const std::exception& e) {
                RCLCPP_ERROR(
                    this->get_logger(), 
                    "Failed to activate publisher '%s': %s", 
                    "/detections", 
                    e.what()
                );
                throw;
            }
        } else {
            RCLCPP_WARN(
                this->get_logger(), 
                "Publisher '%s' is null", 
                "/detections"
            );
        }
        
        // Start timers if they were running before deactivation
        if (main_timer_was_active_) {
            try {
                main_timer_timer_->reset();
                RCLCPP_DEBUG(
                    this->get_logger(), 
                    "Restarted timer: %s", 
                    "main_timer"
                );
            } catch (const std::exception& e) {
                RCLCPP_ERROR(
                    this->get_logger(), 
                    "Failed to restart timer '%s': %s", 
                    "main_timer", 
                    e.what()
                );
                throw;
            }
        } else {
            RCLCPP_DEBUG(
                this->get_logger(), 
                "Skipping timer '%s' (was not active before deactivation)", 
                "main_timer"
            );
        }
        if (processing_timer_was_active_) {
            try {
                processing_timer_timer_->reset();
                RCLCPP_DEBUG(
                    this->get_logger(), 
                    "Restarted timer: %s", 
                    "processing_timer"
                );
            } catch (const std::exception& e) {
                RCLCPP_ERROR(
                    this->get_logger(), 
                    "Failed to restart timer '%s': %s", 
                    "processing_timer", 
                    e.what()
                );
                throw;
            }
        } else {
            RCLCPP_DEBUG(
                this->get_logger(), 
                "Skipping timer '%s' (was not active before deactivation)", 
                "processing_timer"
            );
        }
        
        // Mark node as active
        is_active_ = true;
        
        RCLCPP_INFO(this->get_logger(), "Node activated successfully");
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;
        
    } catch (const std::exception& e) {
        RCLCPP_ERROR(
            this->get_logger(), 
            "Activation failed: %s", 
            e.what()
        );
        
        // Try to clean up partially activated resources
        try {
            on_deactivate(previous_state);
        } catch (...) {
            RCLCPP_ERROR(
                this->get_logger(), 
                "Error during cleanup after failed activation"
            );
        }
        
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::FAILURE;
    }
}

rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
Main_nodeNode::on_deactivate(const rclcpp_lifecycle::State& previous_state)
{
    RCLCPP_INFO(
        this->get_logger(), 
        "Deactivating from [%s] state...", 
        previous_state.label().c_str()
    );
    
    try {
        // Mark node as inactive first to prevent new processing
        is_active_ = false;
        
        // Stop all timers and remember their state
        if (main_timer_timer_) {
            try {
                main_timer_was_active_ = !main_timer_timer_->is_canceled();
                if (main_timer_was_active_) {
                    main_timer_timer_->cancel();
                    RCLCPP_DEBUG(
                        this->get_logger(), 
                        "Stopped timer: %s", 
                        "main_timer"
                    );
                } else {
                    RCLCPP_DEBUG(
                        this->get_logger(), 
                        "Timer '%s' was already stopped", 
                        "main_timer"
                    );
                }
            } catch (const std::exception& e) {
                RCLCPP_ERROR(
                    this->get_logger(), 
                    "Failed to stop timer '%s': %s", 
                    "main_timer", 
                    e.what()
                );
                throw;
            }
        } else {
            RCLCPP_WARN(
                this->get_logger(), 
                "Timer '%s' is null", 
                "main_timer"
            );
        }
        if (processing_timer_timer_) {
            try {
                processing_timer_was_active_ = !processing_timer_timer_->is_canceled();
                if (processing_timer_was_active_) {
                    processing_timer_timer_->cancel();
                    RCLCPP_DEBUG(
                        this->get_logger(), 
                        "Stopped timer: %s", 
                        "processing_timer"
                    );
                } else {
                    RCLCPP_DEBUG(
                        this->get_logger(), 
                        "Timer '%s' was already stopped", 
                        "processing_timer"
                    );
                }
            } catch (const std::exception& e) {
                RCLCPP_ERROR(
                    this->get_logger(), 
                    "Failed to stop timer '%s': %s", 
                    "processing_timer", 
                    e.what()
                );
                throw;
            }
        } else {
            RCLCPP_WARN(
                this->get_logger(), 
                "Timer '%s' is null", 
                "processing_timer"
            );
        }
        
        // Deactivate publishers
        if (chatter_pub_) {
            try {
                auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<std_msgs::msg::String>>(chatter_pub_);
                if (pub) {
                    if (pub->is_activated()) {
                        pub->on_deactivate();
                        RCLCPP_DEBUG(
                            this->get_logger(), 
                            "Deactivated publisher: %s", 
                            "/chatter"
                        );
                    } else {
                        RCLCPP_DEBUG(
                            this->get_logger(), 
                            "Publisher '%s' was not active", 
                            "/chatter"
                        );
                    }
                } else {
                    RCLCPP_WARN(
                        this->get_logger(), 
                        "Publisher '%s' is not a lifecycle publisher", 
                        "/chatter"
                    );
                }
            } catch (const std::exception& e) {
                RCLCPP_ERROR(
                    this->get_logger(), 
                    "Failed to deactivate publisher '%s': %s", 
                    "/chatter", 
                    e.what()
                );
                throw;
            }
        } else {
            RCLCPP_WARN(
                this->get_logger(), 
                "Publisher '%s' is null", 
                "/chatter"
            );
        }
        if (image_processed_pub_) {
            try {
                auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<sensor_msgs::msg::Image>>(image_processed_pub_);
                if (pub) {
                    if (pub->is_activated()) {
                        pub->on_deactivate();
                        RCLCPP_DEBUG(
                            this->get_logger(), 
                            "Deactivated publisher: %s", 
                            "/image_processed"
                        );
                    } else {
                        RCLCPP_DEBUG(
                            this->get_logger(), 
                            "Publisher '%s' was not active", 
                            "/image_processed"
                        );
                    }
                } else {
                    RCLCPP_WARN(
                        this->get_logger(), 
                        "Publisher '%s' is not a lifecycle publisher", 
                        "/image_processed"
                    );
                }
            } catch (const std::exception& e) {
                RCLCPP_ERROR(
                    this->get_logger(), 
                    "Failed to deactivate publisher '%s': %s", 
                    "/image_processed", 
                    e.what()
                );
                throw;
            }
        } else {
            RCLCPP_WARN(
                this->get_logger(), 
                "Publisher '%s' is null", 
                "/image_processed"
            );
        }
        if (detections_pub_) {
            try {
                auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<std_msgs::msg::String>>(detections_pub_);
                if (pub) {
                    if (pub->is_activated()) {
                        pub->on_deactivate();
                        RCLCPP_DEBUG(
                            this->get_logger(), 
                            "Deactivated publisher: %s", 
                            "/detections"
                        );
                    } else {
                        RCLCPP_DEBUG(
                            this->get_logger(), 
                            "Publisher '%s' was not active", 
                            "/detections"
                        );
                    }
                } else {
                    RCLCPP_WARN(
                        this->get_logger(), 
                        "Publisher '%s' is not a lifecycle publisher", 
                        "/detections"
                    );
                }
            } catch (const std::exception& e) {
                RCLCPP_ERROR(
                    this->get_logger(), 
                    "Failed to deactivate publisher '%s': %s", 
                    "/detections", 
                    e.what()
                );
                throw;
            }
        } else {
            RCLCPP_WARN(
                this->get_logger(), 
                "Publisher '%s' is null", 
                "/detections"
            );
        }
        
        RCLCPP_INFO(this->get_logger(), "Node deactivated successfully");
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;
        
    } catch (const std::exception& e) {
        RCLCPP_ERROR(
            this->get_logger(), 
            "Deactivation failed: %s", 
            e.what()
        );
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::FAILURE;
    }
}

rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
Main_nodeNode::on_cleanup(const rclcpp_lifecycle::State& previous_state)
{
    RCLCPP_INFO(
        this->get_logger(), 
        "Cleaning up from [%s] state...", 
        previous_state.label().c_str()
    );
    
    try {
        // Reset timers
        if (main_timer_timer_) {
            try {
                main_timer_timer_->cancel();
                main_timer_timer_.reset();
                main_timer_was_active_ = false;
                RCLCPP_DEBUG(
                    this->get_logger(), 
                    "Reset timer: %s", 
                    "main_timer"
                );
            } catch (const std::exception& e) {
                RCLCPP_ERROR(
                    this->get_logger(), 
                    "Failed to reset timer '%s': %s", 
                    "main_timer", 
                    e.what()
                );
                throw;
            }
        }
        if (processing_timer_timer_) {
            try {
                processing_timer_timer_->cancel();
                processing_timer_timer_.reset();
                processing_timer_was_active_ = false;
                RCLCPP_DEBUG(
                    this->get_logger(), 
                    "Reset timer: %s", 
                    "processing_timer"
                );
            } catch (const std::exception& e) {
                RCLCPP_ERROR(
                    this->get_logger(), 
                    "Failed to reset timer '%s': %s", 
                    "processing_timer", 
                    e.what()
                );
                throw;
            }
        }
        
        // Reset publishers
        if (chatter_pub_) {
            try {
                chatter_pub_.reset();
                RCLCPP_DEBUG(
                    this->get_logger(), 
                    "Reset publisher: %s", 
                    "/chatter"
                );
            } catch (const std::exception& e) {
                RCLCPP_ERROR(
                    this->get_logger(), 
                    "Failed to reset publisher '%s': %s", 
                    "/chatter", 
                    e.what()
                );
                throw;
            }
        }
        if (image_processed_pub_) {
            try {
                image_processed_pub_.reset();
                RCLCPP_DEBUG(
                    this->get_logger(), 
                    "Reset publisher: %s", 
                    "/image_processed"
                );
            } catch (const std::exception& e) {
                RCLCPP_ERROR(
                    this->get_logger(), 
                    "Failed to reset publisher '%s': %s", 
                    "/image_processed", 
                    e.what()
                );
                throw;
            }
        }
        if (detections_pub_) {
            try {
                detections_pub_.reset();
                RCLCPP_DEBUG(
                    this->get_logger(), 
                    "Reset publisher: %s", 
                    "/detections"
                );
            } catch (const std::exception& e) {
                RCLCPP_ERROR(
                    this->get_logger(), 
                    "Failed to reset publisher '%s': %s", 
                    "/detections", 
                    e.what()
                );
                throw;
            }
        }
        
        // Reset subscribers
        if (image_raw_sub_) {
            try {
                image_raw_sub_.reset();
                RCLCPP_DEBUG(
                    this->get_logger(), 
                    "Reset subscriber: %s", 
                    "/camera/image_raw"
                );
            } catch (const std::exception& e) {
                RCLCPP_ERROR(
                    this->get_logger(), 
                    "Failed to reset subscriber '%s': %s", 
                    "/camera/image_raw", 
                    e.what()
                );
                throw;
            }
        }
        if (goal_pose_sub_) {
            try {
                goal_pose_sub_.reset();
                RCLCPP_DEBUG(
                    this->get_logger(), 
                    "Reset subscriber: %s", 
                    "/goal_pose"
                );
            } catch (const std::exception& e) {
                RCLCPP_ERROR(
                    this->get_logger(), 
                    "Failed to reset subscriber '%s': %s", 
                    "/goal_pose", 
                    e.what()
                );
                throw;
            }
        }
        
        // Reset services
        if (process_image_srv_) {
            try {
                process_image_srv_.reset();
                RCLCPP_DEBUG(
                    this->get_logger(), 
                    "Reset service: %s", 
                    "/process_image"
                );
            } catch (const std::exception& e) {
                RCLCPP_ERROR(
                    this->get_logger(), 
                    "Failed to reset service '%s': %s", 
                    "/process_image", 
                    e.what()
                );
                throw;
            }
        }
        
        // Clean up CUDA resources if enabled
        
        RCLCPP_INFO(this->get_logger(), "Node cleanup completed successfully");
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;
        
    } catch (const std::exception& e) {
        RCLCPP_ERROR(
            this->get_logger(), 
            "Cleanup failed: %s", 
            e.what()
        );
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::ERROR;
    }
}

rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
Main_nodeNode::on_shutdown(const rclcpp_lifecycle::State& previous_state)
{
    RCLCPP_INFO(
        this->get_logger(), 
        "Shutting down from [%s] state...", 
        previous_state.label().c_str()
    );
    
    try {
        // Call cleanup first to ensure all resources are released
        on_cleanup(previous_state);
        
        // Additional shutdown-specific cleanup
        
        RCLCPP_INFO(this->get_logger(), "Node shutdown completed successfully");
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;
        
    } catch (const std::exception& e) {
        RCLCPP_ERROR(
            this->get_logger(), 
            "Shutdown failed: %s", 
            e.what()
        );
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::ERROR;
    }
}

// Timer callbacks
void Main_nodeNode::on_main_timer()
{
    // Timer callback implementation
    RCLCPP_DEBUG(this->get_logger(), "Timer main_timer triggered");
}

void Main_nodeNode::on_processing_timer()
{
    // Timer callback implementation
    RCLCPP_DEBUG(this->get_logger(), "Timer processing_timer triggered");
}


// Subscriber callbacks
void Main_nodeNode::on_image_raw(const sensor_msgs::msg::Image::ConstSharedPtr msg)
{
    // Store the latest message for processing
    latest_image_ = msg;
    
    // Process message
    RCLCPP_DEBUG(this->get_logger(), "Received message on /camera/image_raw");
}

void Main_nodeNode::on_goal_pose(const geometry_msgs::msg::PoseStamped::ConstSharedPtr msg)
{
    // Store the latest message for processing
    
    // Process message
    RCLCPP_DEBUG(this->get_logger(), "Received message on /goal_pose");
}


// Service callbacks
void Main_nodeNode::on_process_image(
    const std::shared_ptr<std_srvs::srv::SetBool::Request> request,
    std::shared_ptr<std_srvs::srv::SetBool::Response> response)
{
    // Process service request
    RCLCPP_DEBUG(this->get_logger(), "Service /process_image called");
}


// CUDA methods
bool Main_nodeNode::initializeCuda() {
    RCLCPP_DEBUG(this->get_logger(), "Initializing CUDA resources");
    try {
        // Initialize CUDA device
        cudaError_t status = cudaSetDevice(cuda_device_id_);
        if (status != cudaSuccess) {
            RCLCPP_ERROR(this->get_logger(), 
                       "Failed to set CUDA device %d: %s", 
                       cuda_device_id_, 
                       cudaGetErrorString(status));
            return false;
        }
        
        // Get and log device properties
        cudaDeviceProp props;
        status = cudaGetDeviceProperties(&props, cuda_device_id_);
        if (status == cudaSuccess) {
            RCLCPP_INFO(this->get_logger(), 
                      "Using CUDA device %d: %s (Compute %d.%d)",
                      cuda_device_id_, 
                      props.name, 
                      props.major, 
                      props.minor);
        }
        
        return true;
    } catch (const std::exception& e) {
        RCLCPP_ERROR(this->get_logger(), 
                   "Exception during CUDA initialization: %s", 
                   e.what());
        return false;
    } catch (...) {
        RCLCPP_ERROR(this->get_logger(), 
                   "Unknown exception during CUDA initialization");
        return false;
    }
}

void Main_nodeNode::cleanupCuda() {
    RCLCPP_DEBUG(this->get_logger(), "Cleaning up CUDA resources");
    try {
        // Synchronize and reset the device
        cudaDeviceSynchronize();
        cudaDeviceReset();
    } catch (const std::exception& e) {
        RCLCPP_ERROR(this->get_logger(), 
                   "Exception during CUDA cleanup: %s", 
                   e.what());
    } catch (...) {
        RCLCPP_ERROR(this->get_logger(), 
                   "Unknown exception during CUDA cleanup");
    }
}

std::vector<float> 
Main_nodeNode::processWithCuda(
    const std::vector<float>& input,
    const CudaParams& parameters) 
{
    RCLCPP_DEBUG(this->get_logger(), "Default processWithCuda implementation called");
    // Default implementation returns an empty vector
    // Override this method in derived classes to provide actual CUDA processing
    return {};
}

// CUDA kernel wrappers
std::vector<float> 
Main_nodeNode::call__kernel(
    const std::vector<float>& input,
    const Vector_addParameters& parameters)
{
    RCLCPP_DEBUG(this->get_logger(), "CUDA kernel  called with %zu elements", input.size());
    
    // Default implementation returns an empty vector
    // Override this method in derived classes to provide actual CUDA kernel execution
    return std::vector<float>();
}

std::vector<float> 
Main_nodeNode::call__kernel(
    const std::vector<float>& input,
    const Matrix_multiplyParameters& parameters)
{
    RCLCPP_DEBUG(this->get_logger(), "CUDA kernel  called with %zu elements", input.size());
    
    // Default implementation returns an empty vector
    // Override this method in derived classes to provide actual CUDA kernel execution
    return std::vector<float>();
}

std::vector<float> 
Main_nodeNode::call__kernel(
    const std::vector<float>& input,
    const Image_filterParameters& parameters)
{
    RCLCPP_DEBUG(this->get_logger(), "CUDA kernel  called with %zu elements", input.size());
    
    // Default implementation returns an empty vector
    // Override this method in derived classes to provide actual CUDA kernel execution
    return std::vector<float>();
}


// User-defined C++ methods
void Main_nodeNode::on_timer_callback(
rclcpp::Time current_time) {
    auto message = std_msgs::msg::String();
                message.data = "Hello from robot! Count: " + std::to_string(count_);
                chatter_pub_->publish(message);
                count_++;
        
}
void Main_nodeNode::on_processing_callback(
) {
    // TODO: Implement method logic
    RCLCPP_DEBUG(this->get_logger(), "Method on_processing_callback called");
    
    // Common method implementations
}
void Main_nodeNode::process_image(
const sensor_msgs::msg::Image::SharedPtr image_msg, std::vector<DetectionResult>&& detections) {
    // Method has output parameters, assign to them instead of returning
    detections = cv_bridge::CvImagePtr cv_ptr = cv_bridge::toCvCopy(image_msg, sensor_msgs::image_encodings::BGR8)
            
            // Process with CUDA kernels
            if (use_gpu_) CPP_BLOCK_PLACEHOLDER else process_image_cpu(cv_ptr->image, detections)
            ;
}
void Main_nodeNode::process_image_gpu(
const cv::Mat& image, std::vector<DetectionResult>&& detections) {
    // Method has output parameters, assign to them instead of returning
    detections = size_t image_size = image.total() * image.elemSize()
            uchar* d_input, *d_output
            cudaMalloc(&d_input, image_size)
            cudaMalloc(&d_output, image_size)
            
            // Copy data to GPU
            cudaMemcpy(d_input, image.data, image_size, cudaMemcpyHostToDevice)
            
            // Launch kernel
            dim3 block_size(32, 32)
            dim3 grid_size((image.cols + block_size.x - 1) / block_size.x,
                          (image.rows + block_size.y - 1) / block_size.y)
            
            image_filter_kernel<<<grid_size, block_size>>>(d_input, d_output, image.cols, image.rows)
            
            // Copy result back
            cv::Mat processed_image(image.rows, image.cols, image.type())
            cudaMemcpy(processed_image.data, d_output, image_size, cudaMemcpyDeviceToHost)
            
            // Cleanup
            cudaFree(d_input)
            cudaFree(d_output)
            
            // Run ONNX inference
            run_detection_inference(processed_image, detections)
        ;
}
void Main_nodeNode::run_detection_inference(
const cv::Mat& image, std::vector<DetectionResult>&& detections) {
    // Method has output parameters, assign to them instead of returning
    detections = std::vector<float> input_tensor
            preprocess_for_detection(image, input_tensor)
            
            // Run ONNX inference
            std::vector<float> output_tensor
            if (detection_session_->Run(input_tensor, output_tensor)) postprocess_detections(output_tensor, detections)
            ;
}

// Raw C++ code blocks already placed at file scope above

} // namespace robodsl

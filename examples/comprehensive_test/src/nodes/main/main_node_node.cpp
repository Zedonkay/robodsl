// Generated by RoboDSL - DO NOT EDIT

#include "nodes/main/main_node_node.hpp"
#include <memory>
#include <vector>
#include <map>
#include <cmath>
#include <stdexcept>


namespace robot {

Main_nodeNode::Main_nodeNode(const rclcpp::NodeOptions& options)
: rclcpp_lifecycle::LifecycleNode("main_node", options)
{
    // Initialize parameters
    this->declare_parameter<int>("count", 0);
    this->declare_parameter<double>("rate", 10.0);
    this->declare_parameter<std::string>("name", "robot");
    this->declare_parameter<bool>("enabled", true);
    this->declare_parameter<std::string>("array_coords", "[1.0, 2.0, 3.0]");
    this->declare_parameter<std::string>("dict_config", "{'max_iterations': 100, 'timeout': 5.0, 'enabled': True}");

    // Create publishers
    {
        rclcpp::QoS qos(10);
        qos.reliability(rclcpp::ReliabilityPolicy::Reliable);
        chatter_pub_ = this->create_publisher<std_msgs::msg::String>(
            "/chatter", qos);
    }
    {
        rclcpp::QoS qos(5);
        qos.reliability(rclcpp::ReliabilityPolicy::BestEffort);
        image_processed_pub_ = this->create_publisher<sensor_msgs::msg::Image>(
            "/image_processed", qos);
    }
    {
        rclcpp::QoS qos(20);
        qos.reliability(rclcpp::ReliabilityPolicy::Reliable);
        detections_pub_ = this->create_publisher<std_msgs::msg::String>(
            "/detections", qos);
    }

    // Create subscribers
    {
        rclcpp::QoS qos(5);
        qos.reliability(rclcpp::ReliabilityPolicy::BestEffort);
        auto callback = std::bind(
            &Main_nodeNode::on_image_raw, 
            this, 
            std::placeholders::_1
        );
        image_raw_sub_ = this->create_subscription<sensor_msgs::msg::Image>(
            "/camera/image_raw", 
            qos, 
            callback
        );
    }
    {
        rclcpp::QoS qos(10);
        qos.reliability(rclcpp::ReliabilityPolicy::Reliable);
        auto callback = std::bind(
            &Main_nodeNode::on_goal_pose, 
            this, 
            std::placeholders::_1
        );
        goal_pose_sub_ = this->create_subscription<geometry_msgs::msg::PoseStamped>(
            "/goal_pose", 
            qos, 
            callback
        );
    }

    // Create services
    {
        auto callback = [this](
            const std::shared_ptr<std_srvs::srv::SetBool::Request> request,
            std::shared_ptr<std_srvs::srv::SetBool::Response> response
        ) {
            this->on_process_image(request, response);
        };
        
        process_image_srv_ = this->create_service<std_srvs::srv::SetBool>(
            "/process_image", 
            callback
        );
    }
    

    // Create timers
    main_timer_timer_ = this->create_wall_timer(
        std::chrono::duration<double>(1.0),
        std::bind(&Main_nodeNode::on_main_timer, this)
    );
    processing_timer_timer_ = this->create_wall_timer(
        std::chrono::duration<double>(0.1),
        std::bind(&Main_nodeNode::on_processing_timer, this)
    );

}

Main_nodeNode::~Main_nodeNode()
{
}

// Lifecycle callbacks
rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
Main_nodeNode::on_configure(const rclcpp_lifecycle::State& previous_state)
{
    RCLCPP_INFO(
        this->get_logger(), 
        "Configuring from [%s] state...", 
        previous_state.label().c_str()
    );
    
    try {
        // Load parameters
        {
            rclcpp::Parameter param;
            if (this->get_parameter("count", param)) {
                count_ = param.as_int();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("rate", param)) {
                rate_ = param.as_double();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("name", param)) {
                // Parameter name of type string not supported
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("enabled", param)) {
                enabled_ = param.as_bool();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("array_coords", param)) {
                // Parameter array_coords of type list not supported
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("dict_config", param)) {
                // Parameter dict_config of type dict not supported
            }
        }
        
        RCLCPP_INFO(this->get_logger(), "Configuration completed successfully");
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;
        
    } catch (const std::exception& e) {
        RCLCPP_ERROR(
            this->get_logger(), 
            "Configuration failed: %s", 
            e.what()
        );
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::FAILURE;
    }
}

rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
Main_nodeNode::on_activate(const rclcpp_lifecycle::State& previous_state)
{
    RCLCPP_INFO(
        this->get_logger(), 
        "Activating from [%s] state...", 
        previous_state.label().c_str()
    );
    
    try {
        // Activate publishers
        if (chatter_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<std_msgs::msg::String>>(chatter_pub_);
            if (pub) {
                pub->on_activate();
            }
        }
        if (image_processed_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<sensor_msgs::msg::Image>>(image_processed_pub_);
            if (pub) {
                pub->on_activate();
            }
        }
        if (detections_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<std_msgs::msg::String>>(detections_pub_);
            if (pub) {
                pub->on_activate();
            }
        }
        
        // Mark node as active
        is_active_ = true;
        
        RCLCPP_INFO(this->get_logger(), "Node activated successfully");
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;
        
    } catch (const std::exception& e) {
        RCLCPP_ERROR(
            this->get_logger(), 
            "Activation failed: %s", 
            e.what()
        );
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::FAILURE;
    }
}

rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
Main_nodeNode::on_deactivate(const rclcpp_lifecycle::State& previous_state)
{
    RCLCPP_INFO(
        this->get_logger(), 
        "Deactivating from [%s] state...", 
        previous_state.label().c_str()
    );
    
    try {
        // Mark node as inactive
        is_active_ = false;
        
        // Stop timers
        if (main_timer_timer_) {
            main_timer_was_active_ = !main_timer_timer_->is_canceled();
            if (main_timer_was_active_) {
                main_timer_timer_->cancel();
            }
        }
        if (processing_timer_timer_) {
            processing_timer_was_active_ = !processing_timer_timer_->is_canceled();
            if (processing_timer_was_active_) {
                processing_timer_timer_->cancel();
            }
        }
        
        // Deactivate publishers
        if (chatter_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<std_msgs::msg::String>>(chatter_pub_);
            if (pub && pub->is_activated()) {
                pub->on_deactivate();
            }
        }
        if (image_processed_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<sensor_msgs::msg::Image>>(image_processed_pub_);
            if (pub && pub->is_activated()) {
                pub->on_deactivate();
            }
        }
        if (detections_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<std_msgs::msg::String>>(detections_pub_);
            if (pub && pub->is_activated()) {
                pub->on_deactivate();
            }
        }
        
        RCLCPP_INFO(this->get_logger(), "Node deactivated successfully");
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;
        
    } catch (const std::exception& e) {
        RCLCPP_ERROR(
            this->get_logger(), 
            "Deactivation failed: %s", 
            e.what()
        );
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::FAILURE;
    }
}

rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
Main_nodeNode::on_cleanup(const rclcpp_lifecycle::State& previous_state)
{
    RCLCPP_INFO(
        this->get_logger(), 
        "Cleaning up from [%s] state...", 
        previous_state.label().c_str()
    );
    
    try {
        // Reset timers
        if (main_timer_timer_) {
            main_timer_timer_->cancel();
            main_timer_timer_.reset();
            main_timer_was_active_ = false;
        }
        if (processing_timer_timer_) {
            processing_timer_timer_->cancel();
            processing_timer_timer_.reset();
            processing_timer_was_active_ = false;
        }
        
        // Reset publishers
        if (chatter_pub_) {
            chatter_pub_.reset();
        }
        if (image_processed_pub_) {
            image_processed_pub_.reset();
        }
        if (detections_pub_) {
            detections_pub_.reset();
        }
        
        // Reset subscribers
        if (image_raw_sub_) {
            image_raw_sub_.reset();
        }
        if (goal_pose_sub_) {
            goal_pose_sub_.reset();
        }
        
        // Reset services
        if (process_image_srv_) {
            process_image_srv_.reset();
        }
        
        RCLCPP_INFO(this->get_logger(), "Node cleanup completed successfully");
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;
        
    } catch (const std::exception& e) {
        RCLCPP_ERROR(
            this->get_logger(), 
            "Cleanup failed: %s", 
            e.what()
        );
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::ERROR;
    }
}

rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
Main_nodeNode::on_shutdown(const rclcpp_lifecycle::State& previous_state)
{
    RCLCPP_INFO(
        this->get_logger(), 
        "Shutting down from [%s] state...", 
        previous_state.label().c_str()
    );
    
    try {
        // Call cleanup first
        on_cleanup(previous_state);
        
        RCLCPP_INFO(this->get_logger(), "Node shutdown completed successfully");
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;
        
    } catch (const std::exception& e) {
        RCLCPP_ERROR(
            this->get_logger(), 
            "Shutdown failed: %s", 
            e.what()
        );
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::ERROR;
    }
}

// Timer callbacks
void Main_nodeNode::on_main_timer()
{
    RCLCPP_DEBUG(this->get_logger(), "Timer main_timer triggered");
    
    // Main timer implementation
    auto message = std_msgs::msg::String();
    message.data = "Hello from main_node! Count: " + std::to_string(count_);
    chatter_pub_->publish(message);
    count_++;
}
void Main_nodeNode::on_processing_timer()
{
    RCLCPP_DEBUG(this->get_logger(), "Timer processing_timer triggered");
    
    // Processing timer implementation
    if (enable_processing_) {
        // Process latest data
        RCLCPP_DEBUG(this->get_logger(), "Processing latest data");
    }
}

// Subscriber callbacks
void Main_nodeNode::on_image_raw(const sensor_msgs::msg::Image::ConstSharedPtr msg)
{
    latest_image_ = msg;
    
    RCLCPP_DEBUG(this->get_logger(), "Received message on /camera/image_raw");
}
void Main_nodeNode::on_goal_pose(const geometry_msgs::msg::PoseStamped::ConstSharedPtr msg)
{
    
    RCLCPP_DEBUG(this->get_logger(), "Received message on /goal_pose");
}

// Service callbacks
void Main_nodeNode::on_process_image(
    const std::shared_ptr<std_srvs::srv::SetBool::Request> request,
    std::shared_ptr<std_srvs::srv::SetBool::Response> response)
{
    RCLCPP_DEBUG(this->get_logger(), "Service /process_image called");
    
    // Default service implementation
    response->success = true;
    response->message = "Service /process_image completed successfully";
}



// User-defined C++ methods

} // namespace robot

int main(int argc, char* argv[])
{
    rclcpp::init(argc, argv);
    auto node = std::make_shared<robot::Main_nodeNode>();
    rclcpp::executors::MultiThreadedExecutor executor;
    executor.add_node(node->get_node_base_interface());
    executor.spin();
    rclcpp::shutdown();
    return 0;
}

// Example CUDA kernel using the new input: and output: syntax
cuda_kernels {
    kernel vector_add {
        input: float* a (size)
        input: float* b (size)
        output: float* result (size)
        block_size: (256, 1, 1)
        grid_size: (1, 1, 1)
        code: {
            int idx = blockIdx.x * blockDim.x + threadIdx.x;
            if (idx < size) {
                result[idx] = a[idx] + b[idx];
            }
        }
    }
    
    kernel matrix_multiply {
        input: float* A (rows, cols)
        input: float* B (cols, result_cols)
        output: float* C (rows, result_cols)
        block_size: (16, 16, 1)
        grid_size: (1, 1, 1)
        shared_memory: 1024
        code: {
            int row = blockIdx.y * blockDim.y + threadIdx.y;
            int col = blockIdx.x * blockDim.x + threadIdx.x;
            
            if (row < rows && col < result_cols) {
                float sum = 0.0f;
                for (int k = 0; k < cols; k++) {
                    sum += A[row * cols + k] * B[k * result_cols + col];
                }
                C[row * result_cols + col] = sum;
            }
        }
    }
    
    kernel image_filter {
        input: unsigned char* input_image (width, height)
        input: float* kernel (kernel_size, kernel_size)
        output: unsigned char* output_image (width, height)
        block_size: (32, 32, 1)
        grid_size: (1, 1, 1)
        use_thrust: true
        code: {
            int x = blockIdx.x * blockDim.x + threadIdx.x;
            int y = blockIdx.y * blockDim.y + threadIdx.y;
            
            if (x < width && y < height) {
                float sum = 0.0f;
                int half_kernel = kernel_size / 2;
                
                for (int ky = 0; ky < kernel_size; ky++) {
                    for (int kx = 0; kx < kernel_size; kx++) {
                        int px = x + kx - half_kernel;
                        int py = y + ky - half_kernel;
                        
                        if (px >= 0 && px < width && py >= 0 && py < height) {
                            sum += input_image[py * width + px] * 
                                   kernel[ky * kernel_size + kx];
                        }
                    }
                }
                
                output_image[y * width + x] = (unsigned char)sum;
            }
        }
    }
} 
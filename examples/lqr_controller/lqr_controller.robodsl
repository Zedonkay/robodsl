# LQR Controller Example RoboDSL

project "lqr_controller"

# Main controller node operating on 2-D pose/velocity state
node lqr_node {
    # Publish computed control (ax, ay)
    publisher /control std_msgs/msg/Float32MultiArray

    # Subscribe to raw state and estimated state
    subscriber /state std_msgs/msg/Float32MultiArray
    subscriber /estimated_state std_msgs/msg/Float32MultiArray

    # LQR parameters
    parameter dt : 0.01
    parameter q_pos : 1.0
    parameter q_angle : 0.2
    parameter r_control : 0.01

    # CPU helper functions
    function compute_lqr_gains() -> float[12] {
        # Simple LQR gain computation (placeholder - would use DARE in practice)
        # Returns flattened 2x6 gain matrix
        float[12] K = [
            1.0, 0.0, 0.1, 0.2, 0.0, 0.0,
            0.0, 1.0, 0.0, 0.0, 0.2, 0.1
        ];
        return K;
    }


    function compute_control(float[6] state, float[12] K) -> float[2] {
        # Compute control u = -K * state
        float ux = 0.0, uy = 0.0;
        for (int i = 0; i < 6; ++i) {
            ux += -K[2 * i] * state[i];
            uy += -K[2 * i + 1] * state[i];
        }
        return [ux, uy];
    }


    function estimate_state(float[3] imu_data, float[3] wheel_data, 
                          float prev_theta, float dt) -> float[6] {
        # Simple state estimation from IMU + wheel odometry
        float theta = prev_theta + imu_data[2] * dt;  # Integrate gyro
        float vx = wheel_data[0] * cos(theta);
        float vy = wheel_data[0] * sin(theta);
        
        return [wheel_data[1], wheel_data[2], theta, vx, vy, imu_data[2]];
    }
}

# Shared state estimator sub-node (identical to MPPI example)
node state_estimator {
    publisher /estimated_state std_msgs/msg/Float32MultiArray
    subscriber /imu std_msgs/msg/Float32MultiArray
    subscriber /wheel_odometry std_msgs/msg/Float32
    parameter filter_gain : 0.8
}

# CUDA kernel that evaluates control effort cost for a batch of states using an LQR gain matrix
kernel lqr_cost {
    # Inputs (each length N)
    input float x       # x position
    input float y       # y position
    input float theta   # heading
    input float vx      # x velocity
    input float vy      # y velocity
    input float omega   # angular rate
    input float K       # 12-element flattened 2x6 gain matrix

    # Outputs
    output float cost   # scalar cost per sample

    block_size (256, 1, 1)
    grid_size (8, 1, 1)         # 8 * 256 = 2048 threads
    shared_memory 0

    use_thrust

    include <thrust/transform_reduce.h>
    define N 2048

    code """
    const int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx >= N) return;

    // Assemble local state vector
    float s[6] = {x[idx], y[idx], theta[idx], vx[idx], vy[idx], omega[idx]};

    // Compute control u = -K * s (2D)
    float ux = 0.f, uy = 0.f;
    #pragma unroll
    for (int i = 0; i < 6; ++i) {
        ux += -K[2 * i] * s[i];
        uy += -K[2 * i + 1] * s[i];
    }

    // Quadratic effort cost
    cost[idx] = ux * ux + uy * uy;
    """
}
}
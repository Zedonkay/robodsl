# MPPI Stress Test Example RoboDSL

project "mppi_stress"

node mppi_node {
    # Publish computed control command
    publisher /control std_msgs/msg/Float32

    # Subscribe to raw and estimated state
    subscriber /state std_msgs/msg/Float32
    subscriber /estimated_state std_msgs/msg/Float32MultiArray

    # MPPI parameters
    parameter rollout_count : 2048
    parameter w_position : 1.0
    parameter w_velocity : 0.5
    parameter w_control : 0.01
    parameter w_obstacle : 3.0
}

kernel mppi_rollout {
    # Input arrays (device pointers will be generated)
    input float x               # initial x positions
    input float y               # initial y positions
    input float theta           # initial headings
    input float vx              # initial x velocities
    input float vy              # initial y velocities
    input float omega           # initial angular rates
    input float noise           # random noise vector (per state/control)

    # Output array
    output float cost           # resulting cost of each rollout

    # CUDA launch configuration
    block_size (256, 1, 1)
    grid_size (8, 1, 1)         # 8 * 256 = 2048 threads (matches rollout_count)
    shared_memory 0

    # Enable Thrust usage in generated kernel wrapper
    use_thrust

    # Additional headers & definitions
    include <thrust/device_vector.h>
    include <thrust/transform.h>
    include <thrust/reduce.h>
    define N 2048

    # Actual CUDA kernel code (injected verbatim)
    code """
    // Custom functor for squared value â€“ demonstrates device functor object
    struct SquareFunctor {
        __device__ float operator()(float val) const {
            return val * val;
        }
    };

    // Allocate dynamic shared memory for partial costs
    extern __shared__ float shmem[];

    const int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx >= N) return;

    // Example dynamics: x' = x + noise
    float xi = x[idx] + noise[idx];

    // Example cost calculation using Thrust-style functor (though inline here)
    float c = xi * xi;  // squared error cost

    // Write result
    cost[idx] = c;
    """
}

# State Estimator Node reused by MPPI and future MPC
node state_estimator {
    # Publish estimated full state vector
    publisher /estimated_state std_msgs/msg/Float32MultiArray

    # High-rate sensor inputs
    subscriber /imu std_msgs/msg/Float32MultiArray
    subscriber /wheel_odometry std_msgs/msg/Float32

    # Filter parameters
    parameter filter_gain : 0.8
}

# Enhanced MPPI cost kernel operating on extended state and parameters
kernel mppi_cost {
    # Inputs
    input float x               # position
    input float v               # velocity
    input float u_prev          # previous control
    input float goal            # goal state
    input float weights         # 4-element weight vector
    input float obstacle_pos    # obstacle x coordinate

    # Outputs
    output float cost           # resulting cost per rollout

    block_size (256, 1, 1)
    grid_size (8, 1, 1)         # 8 * 256 = 2048 threads
    shared_memory 0

    use_thrust

    include <thrust/functional.h>
    include <thrust/scan.h>
    define N 2048

    code """
    const int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx >= N) return;

    // Unpack weights
    const float w_pos = weights[0];
    const float w_vel = weights[1];
    const float w_control = weights[2];
    const float w_obs = weights[3];

    // Simple Euler dynamics
    float x_next = x[idx] + v[idx] * 0.01f + u_prev[idx] * 0.5f;
    float v_next = v[idx] + u_prev[idx] * 0.1f;

    // Squared-error terms
    float pos_err = x_next - goal[idx];
    float vel_err = v_next;
    float c = w_pos * pos_err * pos_err + w_vel * vel_err * vel_err;

    // Control effort penalty
    c += w_control * u_prev[idx] * u_prev[idx];

    // Obstacle penalty (inverse distance squared)
    const float dx = x_next - obstacle_pos[0];
    c += w_obs / (dx * dx + 1e-3f);

    cost[idx] = c;
    """
}

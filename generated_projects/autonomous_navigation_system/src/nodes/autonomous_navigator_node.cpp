// Generated by RoboDSL - DO NOT EDIT

#include "nodes/autonomous_navigator_node.hpp"
#include <memory>
#include <vector>
#include <map>
#include <cmath>
#include <stdexcept>



Autonomous_navigatorNode::Autonomous_navigatorNode(const rclcpp::NodeOptions& options)
: rclcpp_lifecycle::LifecycleNode("autonomous_navigator", options)
{
    // Initialize parameters
    this->declare_parameter<double>("map_resolution", 0.05);
    this->declare_parameter<int>("map_width", 1000);
    this->declare_parameter<int>("map_height", 1000);
    this->declare_parameter<double>("min_point_distance", 0.1);
    this->declare_parameter<double>("max_point_distance", 50.0);
    this->declare_parameter<std::string>("yolo_model_path", "yolov8n.onnx");
    this->declare_parameter<std::string>("semantic_model_path", "deeplabv3.onnx");
    this->declare_parameter<double>("confidence_threshold", 0.5);
    this->declare_parameter<double>("max_linear_velocity", 1.0);
    this->declare_parameter<double>("max_angular_velocity", 1.0);
    this->declare_parameter<double>("path_planning_frequency", 10.0);
    this->declare_parameter<double>("slam_update_frequency", 20.0);

    // Create publishers
    {
        rclcpp::QoS qos(10);
        navigation_occupancy_grid_pub_ = this->create_publisher<nav_msgs::msg::OccupancyGrid>(
            "/navigation/occupancy_grid", qos);
    }
    {
        rclcpp::QoS qos(10);
        navigation_detected_objects_pub_ = this->create_publisher<visualization_msgs::msg::MarkerArray>(
            "/navigation/detected_objects", qos);
    }
    {
        rclcpp::QoS qos(10);
        navigation_planned_path_pub_ = this->create_publisher<nav_msgs::msg::Path>(
            "/navigation/planned_path", qos);
    }
    {
        rclcpp::QoS qos(10);
        cmd_vel_pub_ = this->create_publisher<geometry_msgs::msg::Twist>(
            "/cmd_vel", qos);
    }
    {
        rclcpp::QoS qos(10);
        navigation_semantic_map_pub_ = this->create_publisher<sensor_msgs::msg::Image>(
            "/navigation/semantic_map", qos);
    }

    // Create subscribers
    {
        rclcpp::QoS qos(10);
        auto callback = std::bind(
            &Autonomous_navigatorNode::on_velodyne_points, 
            this, 
            std::placeholders::_1
        );
        velodyne_points_sub_ = this->create_subscription<sensor_msgs::msg::PointCloud2>(
            "/velodyne_points", 
            qos, 
            callback
        );
    }
    {
        rclcpp::QoS qos(10);
        auto callback = std::bind(
            &Autonomous_navigatorNode::on_camera_image_raw, 
            this, 
            std::placeholders::_1
        );
        camera_image_raw_sub_ = this->create_subscription<sensor_msgs::msg::Image>(
            "/camera/image_raw", 
            qos, 
            callback
        );
    }
    {
        rclcpp::QoS qos(10);
        auto callback = std::bind(
            &Autonomous_navigatorNode::on_odom, 
            this, 
            std::placeholders::_1
        );
        odom_sub_ = this->create_subscription<nav_msgs::msg::Odometry>(
            "/odom", 
            qos, 
            callback
        );
    }
    {
        rclcpp::QoS qos(10);
        auto callback = std::bind(
            &Autonomous_navigatorNode::on_tf, 
            this, 
            std::placeholders::_1
        );
        tf_sub_ = this->create_subscription<tf2_msgs::msg::TFMessage>(
            "/tf", 
            qos, 
            callback
        );
    }

    // Create services
    

    // Create timers
    slam_timer_timer_ = this->create_wall_timer(
        std::chrono::duration<double>(1.0),
        std::bind(&Autonomous_navigatorNode::on_slam_timer, this)
    );
    planning_timer_timer_ = this->create_wall_timer(
        std::chrono::duration<double>(1.0),
        std::bind(&Autonomous_navigatorNode::on_planning_timer, this)
    );

}

Autonomous_navigatorNode::~Autonomous_navigatorNode()
{
}

// Lifecycle callbacks
rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
Autonomous_navigatorNode::on_configure(const rclcpp_lifecycle::State& previous_state)
{
    RCLCPP_INFO(
        this->get_logger(), 
        "Configuring from [%s] state...", 
        previous_state.label().c_str()
    );
    
    try {
        // Load parameters
        {
            rclcpp::Parameter param;
            if (this->get_parameter("map_resolution", param)) {
                map_resolution_ = param.as_double();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("map_width", param)) {
                map_width_ = param.as_int();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("map_height", param)) {
                map_height_ = param.as_int();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("min_point_distance", param)) {
                min_point_distance_ = param.as_double();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("max_point_distance", param)) {
                max_point_distance_ = param.as_double();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("yolo_model_path", param)) {
                // Parameter yolo_model_path of type string not supported
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("semantic_model_path", param)) {
                // Parameter semantic_model_path of type string not supported
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("confidence_threshold", param)) {
                confidence_threshold_ = param.as_double();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("max_linear_velocity", param)) {
                max_linear_velocity_ = param.as_double();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("max_angular_velocity", param)) {
                max_angular_velocity_ = param.as_double();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("path_planning_frequency", param)) {
                path_planning_frequency_ = param.as_double();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("slam_update_frequency", param)) {
                slam_update_frequency_ = param.as_double();
            }
        }
        
        RCLCPP_INFO(this->get_logger(), "Configuration completed successfully");
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;
        
    } catch (const std::exception& e) {
        RCLCPP_ERROR(
            this->get_logger(), 
            "Configuration failed: %s", 
            e.what()
        );
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::FAILURE;
    }
}

rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
Autonomous_navigatorNode::on_activate(const rclcpp_lifecycle::State& previous_state)
{
    RCLCPP_INFO(
        this->get_logger(), 
        "Activating from [%s] state...", 
        previous_state.label().c_str()
    );
    
    try {
        // Activate publishers
        if (navigation_occupancy_grid_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<nav_msgs::msg::OccupancyGrid>>(navigation_occupancy_grid_pub_);
            if (pub) {
                pub->on_activate();
            }
        }
        if (navigation_detected_objects_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<visualization_msgs::msg::MarkerArray>>(navigation_detected_objects_pub_);
            if (pub) {
                pub->on_activate();
            }
        }
        if (navigation_planned_path_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<nav_msgs::msg::Path>>(navigation_planned_path_pub_);
            if (pub) {
                pub->on_activate();
            }
        }
        if (cmd_vel_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<geometry_msgs::msg::Twist>>(cmd_vel_pub_);
            if (pub) {
                pub->on_activate();
            }
        }
        if (navigation_semantic_map_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<sensor_msgs::msg::Image>>(navigation_semantic_map_pub_);
            if (pub) {
                pub->on_activate();
            }
        }
        
        // Mark node as active
        is_active_ = true;
        
        RCLCPP_INFO(this->get_logger(), "Node activated successfully");
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;
        
    } catch (const std::exception& e) {
        RCLCPP_ERROR(
            this->get_logger(), 
            "Activation failed: %s", 
            e.what()
        );
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::FAILURE;
    }
}

rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
Autonomous_navigatorNode::on_deactivate(const rclcpp_lifecycle::State& previous_state)
{
    RCLCPP_INFO(
        this->get_logger(), 
        "Deactivating from [%s] state...", 
        previous_state.label().c_str()
    );
    
    try {
        // Mark node as inactive
        is_active_ = false;
        
        // Stop timers
        if (slam_timer_timer_) {
            slam_timer_was_active_ = !slam_timer_timer_->is_canceled();
            if (slam_timer_was_active_) {
                slam_timer_timer_->cancel();
            }
        }
        if (planning_timer_timer_) {
            planning_timer_was_active_ = !planning_timer_timer_->is_canceled();
            if (planning_timer_was_active_) {
                planning_timer_timer_->cancel();
            }
        }
        
        // Deactivate publishers
        if (navigation_occupancy_grid_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<nav_msgs::msg::OccupancyGrid>>(navigation_occupancy_grid_pub_);
            if (pub && pub->is_activated()) {
                pub->on_deactivate();
            }
        }
        if (navigation_detected_objects_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<visualization_msgs::msg::MarkerArray>>(navigation_detected_objects_pub_);
            if (pub && pub->is_activated()) {
                pub->on_deactivate();
            }
        }
        if (navigation_planned_path_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<nav_msgs::msg::Path>>(navigation_planned_path_pub_);
            if (pub && pub->is_activated()) {
                pub->on_deactivate();
            }
        }
        if (cmd_vel_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<geometry_msgs::msg::Twist>>(cmd_vel_pub_);
            if (pub && pub->is_activated()) {
                pub->on_deactivate();
            }
        }
        if (navigation_semantic_map_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<sensor_msgs::msg::Image>>(navigation_semantic_map_pub_);
            if (pub && pub->is_activated()) {
                pub->on_deactivate();
            }
        }
        
        RCLCPP_INFO(this->get_logger(), "Node deactivated successfully");
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;
        
    } catch (const std::exception& e) {
        RCLCPP_ERROR(
            this->get_logger(), 
            "Deactivation failed: %s", 
            e.what()
        );
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::FAILURE;
    }
}

rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
Autonomous_navigatorNode::on_cleanup(const rclcpp_lifecycle::State& previous_state)
{
    RCLCPP_INFO(
        this->get_logger(), 
        "Cleaning up from [%s] state...", 
        previous_state.label().c_str()
    );
    
    try {
        // Reset timers
        if (slam_timer_timer_) {
            slam_timer_timer_->cancel();
            slam_timer_timer_.reset();
            slam_timer_was_active_ = false;
        }
        if (planning_timer_timer_) {
            planning_timer_timer_->cancel();
            planning_timer_timer_.reset();
            planning_timer_was_active_ = false;
        }
        
        // Reset publishers
        if (navigation_occupancy_grid_pub_) {
            navigation_occupancy_grid_pub_.reset();
        }
        if (navigation_detected_objects_pub_) {
            navigation_detected_objects_pub_.reset();
        }
        if (navigation_planned_path_pub_) {
            navigation_planned_path_pub_.reset();
        }
        if (cmd_vel_pub_) {
            cmd_vel_pub_.reset();
        }
        if (navigation_semantic_map_pub_) {
            navigation_semantic_map_pub_.reset();
        }
        
        // Reset subscribers
        if (velodyne_points_sub_) {
            velodyne_points_sub_.reset();
        }
        if (camera_image_raw_sub_) {
            camera_image_raw_sub_.reset();
        }
        if (odom_sub_) {
            odom_sub_.reset();
        }
        if (tf_sub_) {
            tf_sub_.reset();
        }
        
        // Reset services
        
        RCLCPP_INFO(this->get_logger(), "Node cleanup completed successfully");
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;
        
    } catch (const std::exception& e) {
        RCLCPP_ERROR(
            this->get_logger(), 
            "Cleanup failed: %s", 
            e.what()
        );
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::ERROR;
    }
}

rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
Autonomous_navigatorNode::on_shutdown(const rclcpp_lifecycle::State& previous_state)
{
    RCLCPP_INFO(
        this->get_logger(), 
        "Shutting down from [%s] state...", 
        previous_state.label().c_str()
    );
    
    try {
        // Call cleanup first
        on_cleanup(previous_state);
        
        RCLCPP_INFO(this->get_logger(), "Node shutdown completed successfully");
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;
        
    } catch (const std::exception& e) {
        RCLCPP_ERROR(
            this->get_logger(), 
            "Shutdown failed: %s", 
            e.what()
        );
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::ERROR;
    }
}

// Timer callbacks
void Autonomous_navigatorNode::on_slam_timer()
{
    RCLCPP_DEBUG(this->get_logger(), "Timer slam_timer triggered");
    
    // Custom timer implementation
    RCLCPP_DEBUG(this->get_logger(), "Custom timer slam_timer executed");
}
void Autonomous_navigatorNode::on_planning_timer()
{
    RCLCPP_DEBUG(this->get_logger(), "Timer planning_timer triggered");
    
    // Custom timer implementation
    RCLCPP_DEBUG(this->get_logger(), "Custom timer planning_timer executed");
}

// Subscriber callbacks
void Autonomous_navigatorNode::on_velodyne_points(const sensor_msgs::msg::PointCloud2::ConstSharedPtr msg)
{
    latest_velodyne_points_ = msg;
    
    RCLCPP_DEBUG(this->get_logger(), "Received message on /velodyne_points");
}
void Autonomous_navigatorNode::on_camera_image_raw(const sensor_msgs::msg::Image::ConstSharedPtr msg)
{
    latest_camera_image_raw_ = msg;
    
    RCLCPP_DEBUG(this->get_logger(), "Received message on /camera/image_raw");
}
void Autonomous_navigatorNode::on_odom(const nav_msgs::msg::Odometry::ConstSharedPtr msg)
{
    latest_odom_ = msg;
    
    RCLCPP_DEBUG(this->get_logger(), "Received message on /odom");
}
void Autonomous_navigatorNode::on_tf(const tf2_msgs::msg::TFMessage::ConstSharedPtr msg)
{
    latest_tf_ = msg;
    
    RCLCPP_DEBUG(this->get_logger(), "Received message on /tf");
}

// Service callbacks



// User-defined C++ methods


int main(int argc, char* argv[])
{
    rclcpp::init(argc, argv);
    auto node = std::make_shared<Autonomous_navigatorNode>();
    rclcpp::executors::MultiThreadedExecutor executor;
    executor.add_node(node->get_node_base_interface());
    executor.spin();
    rclcpp::shutdown();
    return 0;
}

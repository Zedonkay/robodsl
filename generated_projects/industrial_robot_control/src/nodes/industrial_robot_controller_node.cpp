// Generated by RoboDSL - DO NOT EDIT

#include "nodes/industrial_robot_controller_node.hpp"
#include <memory>
#include <vector>
#include <map>
#include <cmath>
#include <stdexcept>



Industrial_robot_controllerNode::Industrial_robot_controllerNode(const rclcpp::NodeOptions& options)
: rclcpp_lifecycle::LifecycleNode("industrial_robot_controller", options)
{
    // Initialize parameters
    this->declare_parameter<double>("control_frequency", 1000.0);
    this->declare_parameter<double>("trajectory_planning_frequency", 100.0);
    this->declare_parameter<double>("collision_detection_frequency", 500.0);
    this->declare_parameter<double>("force_control_frequency", 1000.0);
    this->declare_parameter<double>("max_joint_velocity", 1.0);
    this->declare_parameter<double>("max_joint_acceleration", 2.0);
    this->declare_parameter<double>("safety_margin", 0.1);
    this->declare_parameter<double>("force_threshold", 50.0);
    this->declare_parameter<double>("prediction_horizon", 0.5);
    this->declare_parameter<double>("trajectory_smoothing", 0.1);
    this->declare_parameter<std::string>("joint_limits", "[(-3.14, 3.14), (-3.14, 3.14), (-3.14, 3.14), (-3.14, 3.14), (-3.14, 3.14), (-3.14, 3.14)]");
    this->declare_parameter<std::string>("trajectory_optimizer_path", "trajectory_optimizer.onnx");
    this->declare_parameter<std::string>("collision_predictor_path", "collision_predictor.onnx");
    this->declare_parameter<std::string>("force_estimator_path", "force_estimator.onnx");

    // Create publishers
    {
        rclcpp::QoS qos(10);
        joint_trajectory_pub_ = this->create_publisher<trajectory_msgs::msg::JointTrajectory>(
            "/joint_trajectory", qos);
    }
    {
        rclcpp::QoS qos(10);
        joint_commands_pub_ = this->create_publisher<std_msgs::msg::Float64MultiArray>(
            "/joint_commands", qos);
    }
    {
        rclcpp::QoS qos(10);
        robot_pose_pub_ = this->create_publisher<geometry_msgs::msg::PoseStamped>(
            "/robot_pose", qos);
    }
    {
        rclcpp::QoS qos(10);
        force_feedback_pub_ = this->create_publisher<geometry_msgs::msg::WrenchStamped>(
            "/force_feedback", qos);
    }
    {
        rclcpp::QoS qos(10);
        collision_warning_pub_ = this->create_publisher<std_msgs::msg::Bool>(
            "/collision_warning", qos);
    }
    {
        rclcpp::QoS qos(10);
        motion_prediction_pub_ = this->create_publisher<trajectory_msgs::msg::JointTrajectory>(
            "/motion_prediction", qos);
    }

    // Create subscribers
    {
        rclcpp::QoS qos(10);
        auto callback = std::bind(
            &Industrial_robot_controllerNode::on_joint_states, 
            this, 
            std::placeholders::_1
        );
        joint_states_sub_ = this->create_subscription<sensor_msgs::msg::JointState>(
            "/joint_states", 
            qos, 
            callback
        );
    }
    {
        rclcpp::QoS qos(10);
        auto callback = std::bind(
            &Industrial_robot_controllerNode::on_target_pose, 
            this, 
            std::placeholders::_1
        );
        target_pose_sub_ = this->create_subscription<geometry_msgs::msg::PoseStamped>(
            "/target_pose", 
            qos, 
            callback
        );
    }
    {
        rclcpp::QoS qos(10);
        auto callback = std::bind(
            &Industrial_robot_controllerNode::on_force_sensor, 
            this, 
            std::placeholders::_1
        );
        force_sensor_sub_ = this->create_subscription<geometry_msgs::msg::WrenchStamped>(
            "/force_sensor", 
            qos, 
            callback
        );
    }
    {
        rclcpp::QoS qos(10);
        auto callback = std::bind(
            &Industrial_robot_controllerNode::on_robot_status, 
            this, 
            std::placeholders::_1
        );
        robot_status_sub_ = this->create_subscription<std_msgs::msg::Bool>(
            "/robot_status", 
            qos, 
            callback
        );
    }
    {
        rclcpp::QoS qos(10);
        auto callback = std::bind(
            &Industrial_robot_controllerNode::on_emergency_stop, 
            this, 
            std::placeholders::_1
        );
        emergency_stop_sub_ = this->create_subscription<std_msgs::msg::Bool>(
            "/emergency_stop", 
            qos, 
            callback
        );
    }

    // Create services
    

    // Create timers
    control_timer_timer_ = this->create_wall_timer(
        std::chrono::duration<double>(1.0),
        std::bind(&Industrial_robot_controllerNode::on_control_timer, this)
    );
    planning_timer_timer_ = this->create_wall_timer(
        std::chrono::duration<double>(1.0),
        std::bind(&Industrial_robot_controllerNode::on_planning_timer, this)
    );
    safety_timer_timer_ = this->create_wall_timer(
        std::chrono::duration<double>(1.0),
        std::bind(&Industrial_robot_controllerNode::on_safety_timer, this)
    );

}

Industrial_robot_controllerNode::~Industrial_robot_controllerNode()
{
}

// Lifecycle callbacks
rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
Industrial_robot_controllerNode::on_configure(const rclcpp_lifecycle::State& previous_state)
{
    RCLCPP_INFO(
        this->get_logger(), 
        "Configuring from [%s] state...", 
        previous_state.label().c_str()
    );
    
    try {
        // Load parameters
        {
            rclcpp::Parameter param;
            if (this->get_parameter("control_frequency", param)) {
                control_frequency_ = param.as_double();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("trajectory_planning_frequency", param)) {
                trajectory_planning_frequency_ = param.as_double();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("collision_detection_frequency", param)) {
                collision_detection_frequency_ = param.as_double();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("force_control_frequency", param)) {
                force_control_frequency_ = param.as_double();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("max_joint_velocity", param)) {
                max_joint_velocity_ = param.as_double();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("max_joint_acceleration", param)) {
                max_joint_acceleration_ = param.as_double();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("safety_margin", param)) {
                safety_margin_ = param.as_double();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("force_threshold", param)) {
                force_threshold_ = param.as_double();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("prediction_horizon", param)) {
                prediction_horizon_ = param.as_double();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("trajectory_smoothing", param)) {
                trajectory_smoothing_ = param.as_double();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("joint_limits", param)) {
                // Parameter joint_limits of type string not supported
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("trajectory_optimizer_path", param)) {
                // Parameter trajectory_optimizer_path of type string not supported
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("collision_predictor_path", param)) {
                // Parameter collision_predictor_path of type string not supported
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("force_estimator_path", param)) {
                // Parameter force_estimator_path of type string not supported
            }
        }
        
        RCLCPP_INFO(this->get_logger(), "Configuration completed successfully");
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;
        
    } catch (const std::exception& e) {
        RCLCPP_ERROR(
            this->get_logger(), 
            "Configuration failed: %s", 
            e.what()
        );
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::FAILURE;
    }
}

rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
Industrial_robot_controllerNode::on_activate(const rclcpp_lifecycle::State& previous_state)
{
    RCLCPP_INFO(
        this->get_logger(), 
        "Activating from [%s] state...", 
        previous_state.label().c_str()
    );
    
    try {
        // Activate publishers
        if (joint_trajectory_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<trajectory_msgs::msg::JointTrajectory>>(joint_trajectory_pub_);
            if (pub) {
                pub->on_activate();
            }
        }
        if (joint_commands_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<std_msgs::msg::Float64MultiArray>>(joint_commands_pub_);
            if (pub) {
                pub->on_activate();
            }
        }
        if (robot_pose_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<geometry_msgs::msg::PoseStamped>>(robot_pose_pub_);
            if (pub) {
                pub->on_activate();
            }
        }
        if (force_feedback_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<geometry_msgs::msg::WrenchStamped>>(force_feedback_pub_);
            if (pub) {
                pub->on_activate();
            }
        }
        if (collision_warning_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<std_msgs::msg::Bool>>(collision_warning_pub_);
            if (pub) {
                pub->on_activate();
            }
        }
        if (motion_prediction_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<trajectory_msgs::msg::JointTrajectory>>(motion_prediction_pub_);
            if (pub) {
                pub->on_activate();
            }
        }
        
        // Mark node as active
        is_active_ = true;
        
        RCLCPP_INFO(this->get_logger(), "Node activated successfully");
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;
        
    } catch (const std::exception& e) {
        RCLCPP_ERROR(
            this->get_logger(), 
            "Activation failed: %s", 
            e.what()
        );
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::FAILURE;
    }
}

rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
Industrial_robot_controllerNode::on_deactivate(const rclcpp_lifecycle::State& previous_state)
{
    RCLCPP_INFO(
        this->get_logger(), 
        "Deactivating from [%s] state...", 
        previous_state.label().c_str()
    );
    
    try {
        // Mark node as inactive
        is_active_ = false;
        
        // Stop timers
        if (control_timer_timer_) {
            control_timer_was_active_ = !control_timer_timer_->is_canceled();
            if (control_timer_was_active_) {
                control_timer_timer_->cancel();
            }
        }
        if (planning_timer_timer_) {
            planning_timer_was_active_ = !planning_timer_timer_->is_canceled();
            if (planning_timer_was_active_) {
                planning_timer_timer_->cancel();
            }
        }
        if (safety_timer_timer_) {
            safety_timer_was_active_ = !safety_timer_timer_->is_canceled();
            if (safety_timer_was_active_) {
                safety_timer_timer_->cancel();
            }
        }
        
        // Deactivate publishers
        if (joint_trajectory_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<trajectory_msgs::msg::JointTrajectory>>(joint_trajectory_pub_);
            if (pub && pub->is_activated()) {
                pub->on_deactivate();
            }
        }
        if (joint_commands_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<std_msgs::msg::Float64MultiArray>>(joint_commands_pub_);
            if (pub && pub->is_activated()) {
                pub->on_deactivate();
            }
        }
        if (robot_pose_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<geometry_msgs::msg::PoseStamped>>(robot_pose_pub_);
            if (pub && pub->is_activated()) {
                pub->on_deactivate();
            }
        }
        if (force_feedback_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<geometry_msgs::msg::WrenchStamped>>(force_feedback_pub_);
            if (pub && pub->is_activated()) {
                pub->on_deactivate();
            }
        }
        if (collision_warning_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<std_msgs::msg::Bool>>(collision_warning_pub_);
            if (pub && pub->is_activated()) {
                pub->on_deactivate();
            }
        }
        if (motion_prediction_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<trajectory_msgs::msg::JointTrajectory>>(motion_prediction_pub_);
            if (pub && pub->is_activated()) {
                pub->on_deactivate();
            }
        }
        
        RCLCPP_INFO(this->get_logger(), "Node deactivated successfully");
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;
        
    } catch (const std::exception& e) {
        RCLCPP_ERROR(
            this->get_logger(), 
            "Deactivation failed: %s", 
            e.what()
        );
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::FAILURE;
    }
}

rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
Industrial_robot_controllerNode::on_cleanup(const rclcpp_lifecycle::State& previous_state)
{
    RCLCPP_INFO(
        this->get_logger(), 
        "Cleaning up from [%s] state...", 
        previous_state.label().c_str()
    );
    
    try {
        // Reset timers
        if (control_timer_timer_) {
            control_timer_timer_->cancel();
            control_timer_timer_.reset();
            control_timer_was_active_ = false;
        }
        if (planning_timer_timer_) {
            planning_timer_timer_->cancel();
            planning_timer_timer_.reset();
            planning_timer_was_active_ = false;
        }
        if (safety_timer_timer_) {
            safety_timer_timer_->cancel();
            safety_timer_timer_.reset();
            safety_timer_was_active_ = false;
        }
        
        // Reset publishers
        if (joint_trajectory_pub_) {
            joint_trajectory_pub_.reset();
        }
        if (joint_commands_pub_) {
            joint_commands_pub_.reset();
        }
        if (robot_pose_pub_) {
            robot_pose_pub_.reset();
        }
        if (force_feedback_pub_) {
            force_feedback_pub_.reset();
        }
        if (collision_warning_pub_) {
            collision_warning_pub_.reset();
        }
        if (motion_prediction_pub_) {
            motion_prediction_pub_.reset();
        }
        
        // Reset subscribers
        if (joint_states_sub_) {
            joint_states_sub_.reset();
        }
        if (target_pose_sub_) {
            target_pose_sub_.reset();
        }
        if (force_sensor_sub_) {
            force_sensor_sub_.reset();
        }
        if (robot_status_sub_) {
            robot_status_sub_.reset();
        }
        if (emergency_stop_sub_) {
            emergency_stop_sub_.reset();
        }
        
        // Reset services
        
        RCLCPP_INFO(this->get_logger(), "Node cleanup completed successfully");
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;
        
    } catch (const std::exception& e) {
        RCLCPP_ERROR(
            this->get_logger(), 
            "Cleanup failed: %s", 
            e.what()
        );
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::ERROR;
    }
}

rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
Industrial_robot_controllerNode::on_shutdown(const rclcpp_lifecycle::State& previous_state)
{
    RCLCPP_INFO(
        this->get_logger(), 
        "Shutting down from [%s] state...", 
        previous_state.label().c_str()
    );
    
    try {
        // Call cleanup first
        on_cleanup(previous_state);
        
        RCLCPP_INFO(this->get_logger(), "Node shutdown completed successfully");
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;
        
    } catch (const std::exception& e) {
        RCLCPP_ERROR(
            this->get_logger(), 
            "Shutdown failed: %s", 
            e.what()
        );
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::ERROR;
    }
}

// Timer callbacks
void Industrial_robot_controllerNode::on_control_timer()
{
    RCLCPP_DEBUG(this->get_logger(), "Timer control_timer triggered");
    
    // Custom timer implementation
    RCLCPP_DEBUG(this->get_logger(), "Custom timer control_timer executed");
}
void Industrial_robot_controllerNode::on_planning_timer()
{
    RCLCPP_DEBUG(this->get_logger(), "Timer planning_timer triggered");
    
    // Custom timer implementation
    RCLCPP_DEBUG(this->get_logger(), "Custom timer planning_timer executed");
}
void Industrial_robot_controllerNode::on_safety_timer()
{
    RCLCPP_DEBUG(this->get_logger(), "Timer safety_timer triggered");
    
    // Custom timer implementation
    RCLCPP_DEBUG(this->get_logger(), "Custom timer safety_timer executed");
}

// Subscriber callbacks
void Industrial_robot_controllerNode::on_joint_states(const sensor_msgs::msg::JointState::ConstSharedPtr msg)
{
    latest_joint_states_ = msg;
    
    RCLCPP_DEBUG(this->get_logger(), "Received message on /joint_states");
}
void Industrial_robot_controllerNode::on_target_pose(const geometry_msgs::msg::PoseStamped::ConstSharedPtr msg)
{
    latest_target_pose_ = msg;
    
    RCLCPP_DEBUG(this->get_logger(), "Received message on /target_pose");
}
void Industrial_robot_controllerNode::on_force_sensor(const geometry_msgs::msg::WrenchStamped::ConstSharedPtr msg)
{
    latest_force_sensor_ = msg;
    
    RCLCPP_DEBUG(this->get_logger(), "Received message on /force_sensor");
}
void Industrial_robot_controllerNode::on_robot_status(const std_msgs::msg::Bool::ConstSharedPtr msg)
{
    latest_robot_status_ = msg;
    
    RCLCPP_DEBUG(this->get_logger(), "Received message on /robot_status");
}
void Industrial_robot_controllerNode::on_emergency_stop(const std_msgs::msg::Bool::ConstSharedPtr msg)
{
    latest_emergency_stop_ = msg;
    
    RCLCPP_DEBUG(this->get_logger(), "Received message on /emergency_stop");
}

// Service callbacks



// User-defined C++ methods


int main(int argc, char* argv[])
{
    rclcpp::init(argc, argv);
    auto node = std::make_shared<Industrial_robot_controllerNode>();
    rclcpp::executors::MultiThreadedExecutor executor;
    executor.add_node(node->get_node_base_interface());
    executor.spin();
    rclcpp::shutdown();
    return 0;
}

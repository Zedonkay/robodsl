// Generated by RoboDSL - DO NOT EDIT

#ifndef INDUSTRIAL_ROBOT_CONTROLLER_NODE_HPP
#define INDUSTRIAL_ROBOT_CONTROLLER_NODE_HPP

// Standard includes
#include <memory>
#include <string>
#include <vector>
#include <map>
#include <cmath>
#include <functional>
#include <thread>
#include <atomic>

// ROS2 includes
#include <rclcpp/rclcpp.hpp>
#include <rclcpp_lifecycle/lifecycle_node.hpp>
#include <rclcpp_lifecycle/lifecycle_publisher.hpp>
#include <rclcpp_lifecycle/node_interfaces/lifecycle_node_interface.hpp>

// Message includes
#include <geometry_msgs/msg/pose_stamped.hpp>
#include <geometry_msgs/msg/wrench_stamped.hpp>
#include <sensor_msgs/msg/joint_state.hpp>
#include <std_msgs/msg/bool.hpp>
#include <std_msgs/msg/float64_multi_array.hpp>
#include <trajectory_msgs/msg/joint_trajectory.hpp>

// Additional ROS2 includes

// CUDA includes (if needed)

// OpenCV includes (if needed)

// Type definitions
#ifndef __UCHAR_TYPE__
typedef unsigned char uchar;
#endif

// Forward declarations for custom types

// CUDA parameter structs


class Industrial_robot_controllerNode : public rclcpp_lifecycle::LifecycleNode {
public:
    explicit Industrial_robot_controllerNode(const rclcpp::NodeOptions& options = rclcpp::NodeOptions());
    virtual ~Industrial_robot_controllerNode();

    // Lifecycle callbacks
    rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn 
    on_configure(const rclcpp_lifecycle::State& previous_state) override;
    
    rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn 
    on_activate(const rclcpp_lifecycle::State& previous_state) override;
    
    rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn 
    on_deactivate(const rclcpp_lifecycle::State& previous_state) override;
    
    rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn 
    on_cleanup(const rclcpp_lifecycle::State& previous_state) override;
    
    rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn 
    on_shutdown(const rclcpp_lifecycle::State& previous_state) override;

    // Timer callbacks
    void on_control_timer();
    void on_planning_timer();
    void on_safety_timer();

    // Subscriber callbacks
    void on_joint_states(const sensor_msgs::msg::JointState::ConstSharedPtr msg);
    void on_target_pose(const geometry_msgs::msg::PoseStamped::ConstSharedPtr msg);
    void on_force_sensor(const geometry_msgs::msg::WrenchStamped::ConstSharedPtr msg);
    void on_robot_status(const std_msgs::msg::Bool::ConstSharedPtr msg);
    void on_emergency_stop(const std_msgs::msg::Bool::ConstSharedPtr msg);

    // Service callbacks



    // User-defined C++ methods

private:
    // Publishers
    std::shared_ptr<rclcpp_lifecycle::LifecyclePublisher<trajectory_msgs::msg::JointTrajectory>> joint_trajectory_pub_;
    std::shared_ptr<rclcpp_lifecycle::LifecyclePublisher<std_msgs::msg::Float64MultiArray>> joint_commands_pub_;
    std::shared_ptr<rclcpp_lifecycle::LifecyclePublisher<geometry_msgs::msg::PoseStamped>> robot_pose_pub_;
    std::shared_ptr<rclcpp_lifecycle::LifecyclePublisher<geometry_msgs::msg::WrenchStamped>> force_feedback_pub_;
    std::shared_ptr<rclcpp_lifecycle::LifecyclePublisher<std_msgs::msg::Bool>> collision_warning_pub_;
    std::shared_ptr<rclcpp_lifecycle::LifecyclePublisher<trajectory_msgs::msg::JointTrajectory>> motion_prediction_pub_;

    // Subscribers
    rclcpp::Subscription<sensor_msgs::msg::JointState>::SharedPtr joint_states_sub_;
    rclcpp::Subscription<geometry_msgs::msg::PoseStamped>::SharedPtr target_pose_sub_;
    rclcpp::Subscription<geometry_msgs::msg::WrenchStamped>::SharedPtr force_sensor_sub_;
    rclcpp::Subscription<std_msgs::msg::Bool>::SharedPtr robot_status_sub_;
    rclcpp::Subscription<std_msgs::msg::Bool>::SharedPtr emergency_stop_sub_;

    // Services


    // Timers
    rclcpp::TimerBase::SharedPtr control_timer_timer_;
    rclcpp::TimerBase::SharedPtr planning_timer_timer_;
    rclcpp::TimerBase::SharedPtr safety_timer_timer_;

    // Lifecycle state tracking
    std::atomic<bool> is_active_{false};
    bool control_timer_was_active_{false};
    bool planning_timer_was_active_{false};
    bool safety_timer_was_active_{false};

    
    // Processing control
    bool enable_processing_{true};

    // Parameters
    double control_frequency_;
    double trajectory_planning_frequency_;
    double collision_detection_frequency_;
    double force_control_frequency_;
    double max_joint_velocity_;
    double max_joint_acceleration_;
    double safety_margin_;
    double force_threshold_;
    double prediction_horizon_;
    double trajectory_smoothing_;
    // Parameter joint_limits of type string not supported in member variables
    // Parameter trajectory_optimizer_path of type string not supported in member variables
    // Parameter collision_predictor_path of type string not supported in member variables
    // Parameter force_estimator_path of type string not supported in member variables

    // Latest message storage (per-subscriber)
    sensor_msgs::msg::JointState::ConstSharedPtr latest_joint_states_;
    geometry_msgs::msg::PoseStamped::ConstSharedPtr latest_target_pose_;
    geometry_msgs::msg::WrenchStamped::ConstSharedPtr latest_force_sensor_;
    std_msgs::msg::Bool::ConstSharedPtr latest_robot_status_;
    std_msgs::msg::Bool::ConstSharedPtr latest_emergency_stop_;

    // CUDA kernel member variables

    // Helper methods
    void init_parameters();
    void init_publishers();
    void init_subscribers();
    void init_services();
    void init_timers();
};


#endif // INDUSTRIAL_ROBOT_CONTROLLER_NODE_HPP

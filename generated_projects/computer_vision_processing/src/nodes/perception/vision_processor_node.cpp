// Generated by RoboDSL - DO NOT EDIT

#include "nodes/perception/vision_processor_node.hpp"
#include <memory>
#include <vector>
#include <map>
#include <cmath>
#include <stdexcept>



Vision_processorNode::Vision_processorNode(const rclcpp::NodeOptions& options)
: rclcpp_lifecycle::LifecycleNode("vision_processor", options)
{
    // Initialize parameters
    this->declare_parameter<double>("processing_frequency", 30.0);
    this->declare_parameter<int>("image_width", 1920);
    this->declare_parameter<int>("image_height", 1080);
    this->declare_parameter<int>("resize_width", 640);
    this->declare_parameter<int>("resize_height", 480);
    this->declare_parameter<double>("confidence_threshold", 0.5);
    this->declare_parameter<double>("nms_threshold", 0.4);
    this->declare_parameter<int>("max_detections", 100);
    this->declare_parameter<bool>("enable_edge_detection", true);
    this->declare_parameter<bool>("enable_optical_flow", true);
    this->declare_parameter<bool>("enable_feature_matching", false);
    this->declare_parameter<double>("gaussian_blur_sigma", 1.0);
    this->declare_parameter<double>("edge_detection_threshold", 0.1);
    this->declare_parameter<std::string>("object_detector_path", "yolov8n.onnx");
    this->declare_parameter<std::string>("face_recognition_path", "arcface_r100.onnx");
    this->declare_parameter<std::string>("pose_estimation_path", "hrnet_w32.onnx");
    this->declare_parameter<std::string>("depth_estimation_path", "monodepth2.onnx");
    this->declare_parameter<std::string>("optical_flow_path", "raft_small.onnx");

    // Create publishers
    {
        rclcpp::QoS qos(10);
        vision_processed_image_pub_ = this->create_publisher<sensor_msgs::msg::Image>(
            "/vision/processed_image", qos);
    }
    {
        rclcpp::QoS qos(10);
        vision_detected_objects_pub_ = this->create_publisher<std_msgs::msg::Float32MultiArray>(
            "/vision/detected_objects", qos);
    }
    {
        rclcpp::QoS qos(10);
        vision_face_embeddings_pub_ = this->create_publisher<std_msgs::msg::Float32MultiArray>(
            "/vision/face_embeddings", qos);
    }
    {
        rclcpp::QoS qos(10);
        vision_human_poses_pub_ = this->create_publisher<std_msgs::msg::Float32MultiArray>(
            "/vision/human_poses", qos);
    }
    {
        rclcpp::QoS qos(10);
        vision_depth_map_pub_ = this->create_publisher<sensor_msgs::msg::Image>(
            "/vision/depth_map", qos);
    }
    {
        rclcpp::QoS qos(10);
        vision_optical_flow_pub_ = this->create_publisher<sensor_msgs::msg::Image>(
            "/vision/optical_flow", qos);
    }
    {
        rclcpp::QoS qos(10);
        vision_feature_matches_pub_ = this->create_publisher<std_msgs::msg::Float32MultiArray>(
            "/vision/feature_matches", qos);
    }
    {
        rclcpp::QoS qos(10);
        vision_edge_map_pub_ = this->create_publisher<sensor_msgs::msg::Image>(
            "/vision/edge_map", qos);
    }

    // Create subscribers
    {
        rclcpp::QoS qos(10);
        auto callback = std::bind(
            &Vision_processorNode::on_camera_image_raw, 
            this, 
            std::placeholders::_1
        );
        camera_image_raw_sub_ = this->create_subscription<sensor_msgs::msg::Image>(
            "/camera/image_raw", 
            qos, 
            callback
        );
    }
    {
        rclcpp::QoS qos(10);
        auto callback = std::bind(
            &Vision_processorNode::on_camera_camera_info, 
            this, 
            std::placeholders::_1
        );
        camera_camera_info_sub_ = this->create_subscription<sensor_msgs::msg::CameraInfo>(
            "/camera/camera_info", 
            qos, 
            callback
        );
    }
    {
        rclcpp::QoS qos(10);
        auto callback = std::bind(
            &Vision_processorNode::on_camera2_image_raw, 
            this, 
            std::placeholders::_1
        );
        camera2_image_raw_sub_ = this->create_subscription<sensor_msgs::msg::Image>(
            "/camera2/image_raw", 
            qos, 
            callback
        );
    }
    {
        rclcpp::QoS qos(10);
        auto callback = std::bind(
            &Vision_processorNode::on_camera2_camera_info, 
            this, 
            std::placeholders::_1
        );
        camera2_camera_info_sub_ = this->create_subscription<sensor_msgs::msg::CameraInfo>(
            "/camera2/camera_info", 
            qos, 
            callback
        );
    }

    // Create services
    

    // Create timers
    processing_timer_timer_ = this->create_wall_timer(
        std::chrono::duration<double>(1.0),
        std::bind(&Vision_processorNode::on_processing_timer, this)
    );

}

Vision_processorNode::~Vision_processorNode()
{
}

// Lifecycle callbacks
rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
Vision_processorNode::on_configure(const rclcpp_lifecycle::State& previous_state)
{
    RCLCPP_INFO(
        this->get_logger(), 
        "Configuring from [%s] state...", 
        previous_state.label().c_str()
    );
    
    try {
        // Load parameters
        {
            rclcpp::Parameter param;
            if (this->get_parameter("processing_frequency", param)) {
                processing_frequency_ = param.as_double();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("image_width", param)) {
                image_width_ = param.as_int();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("image_height", param)) {
                image_height_ = param.as_int();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("resize_width", param)) {
                resize_width_ = param.as_int();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("resize_height", param)) {
                resize_height_ = param.as_int();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("confidence_threshold", param)) {
                confidence_threshold_ = param.as_double();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("nms_threshold", param)) {
                nms_threshold_ = param.as_double();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("max_detections", param)) {
                max_detections_ = param.as_int();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("enable_edge_detection", param)) {
                enable_edge_detection_ = param.as_bool();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("enable_optical_flow", param)) {
                enable_optical_flow_ = param.as_bool();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("enable_feature_matching", param)) {
                enable_feature_matching_ = param.as_bool();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("gaussian_blur_sigma", param)) {
                gaussian_blur_sigma_ = param.as_double();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("edge_detection_threshold", param)) {
                edge_detection_threshold_ = param.as_double();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("object_detector_path", param)) {
                // Parameter object_detector_path of type string not supported
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("face_recognition_path", param)) {
                // Parameter face_recognition_path of type string not supported
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("pose_estimation_path", param)) {
                // Parameter pose_estimation_path of type string not supported
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("depth_estimation_path", param)) {
                // Parameter depth_estimation_path of type string not supported
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("optical_flow_path", param)) {
                // Parameter optical_flow_path of type string not supported
            }
        }
        
        RCLCPP_INFO(this->get_logger(), "Configuration completed successfully");
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;
        
    } catch (const std::exception& e) {
        RCLCPP_ERROR(
            this->get_logger(), 
            "Configuration failed: %s", 
            e.what()
        );
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::FAILURE;
    }
}

rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
Vision_processorNode::on_activate(const rclcpp_lifecycle::State& previous_state)
{
    RCLCPP_INFO(
        this->get_logger(), 
        "Activating from [%s] state...", 
        previous_state.label().c_str()
    );
    
    try {
        // Activate publishers
        if (vision_processed_image_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<sensor_msgs::msg::Image>>(vision_processed_image_pub_);
            if (pub) {
                pub->on_activate();
            }
        }
        if (vision_detected_objects_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<std_msgs::msg::Float32MultiArray>>(vision_detected_objects_pub_);
            if (pub) {
                pub->on_activate();
            }
        }
        if (vision_face_embeddings_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<std_msgs::msg::Float32MultiArray>>(vision_face_embeddings_pub_);
            if (pub) {
                pub->on_activate();
            }
        }
        if (vision_human_poses_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<std_msgs::msg::Float32MultiArray>>(vision_human_poses_pub_);
            if (pub) {
                pub->on_activate();
            }
        }
        if (vision_depth_map_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<sensor_msgs::msg::Image>>(vision_depth_map_pub_);
            if (pub) {
                pub->on_activate();
            }
        }
        if (vision_optical_flow_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<sensor_msgs::msg::Image>>(vision_optical_flow_pub_);
            if (pub) {
                pub->on_activate();
            }
        }
        if (vision_feature_matches_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<std_msgs::msg::Float32MultiArray>>(vision_feature_matches_pub_);
            if (pub) {
                pub->on_activate();
            }
        }
        if (vision_edge_map_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<sensor_msgs::msg::Image>>(vision_edge_map_pub_);
            if (pub) {
                pub->on_activate();
            }
        }
        
        // Mark node as active
        is_active_ = true;
        
        RCLCPP_INFO(this->get_logger(), "Node activated successfully");
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;
        
    } catch (const std::exception& e) {
        RCLCPP_ERROR(
            this->get_logger(), 
            "Activation failed: %s", 
            e.what()
        );
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::FAILURE;
    }
}

rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
Vision_processorNode::on_deactivate(const rclcpp_lifecycle::State& previous_state)
{
    RCLCPP_INFO(
        this->get_logger(), 
        "Deactivating from [%s] state...", 
        previous_state.label().c_str()
    );
    
    try {
        // Mark node as inactive
        is_active_ = false;
        
        // Stop timers
        if (processing_timer_timer_) {
            processing_timer_was_active_ = !processing_timer_timer_->is_canceled();
            if (processing_timer_was_active_) {
                processing_timer_timer_->cancel();
            }
        }
        
        // Deactivate publishers
        if (vision_processed_image_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<sensor_msgs::msg::Image>>(vision_processed_image_pub_);
            if (pub && pub->is_activated()) {
                pub->on_deactivate();
            }
        }
        if (vision_detected_objects_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<std_msgs::msg::Float32MultiArray>>(vision_detected_objects_pub_);
            if (pub && pub->is_activated()) {
                pub->on_deactivate();
            }
        }
        if (vision_face_embeddings_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<std_msgs::msg::Float32MultiArray>>(vision_face_embeddings_pub_);
            if (pub && pub->is_activated()) {
                pub->on_deactivate();
            }
        }
        if (vision_human_poses_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<std_msgs::msg::Float32MultiArray>>(vision_human_poses_pub_);
            if (pub && pub->is_activated()) {
                pub->on_deactivate();
            }
        }
        if (vision_depth_map_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<sensor_msgs::msg::Image>>(vision_depth_map_pub_);
            if (pub && pub->is_activated()) {
                pub->on_deactivate();
            }
        }
        if (vision_optical_flow_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<sensor_msgs::msg::Image>>(vision_optical_flow_pub_);
            if (pub && pub->is_activated()) {
                pub->on_deactivate();
            }
        }
        if (vision_feature_matches_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<std_msgs::msg::Float32MultiArray>>(vision_feature_matches_pub_);
            if (pub && pub->is_activated()) {
                pub->on_deactivate();
            }
        }
        if (vision_edge_map_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<sensor_msgs::msg::Image>>(vision_edge_map_pub_);
            if (pub && pub->is_activated()) {
                pub->on_deactivate();
            }
        }
        
        RCLCPP_INFO(this->get_logger(), "Node deactivated successfully");
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;
        
    } catch (const std::exception& e) {
        RCLCPP_ERROR(
            this->get_logger(), 
            "Deactivation failed: %s", 
            e.what()
        );
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::FAILURE;
    }
}

rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
Vision_processorNode::on_cleanup(const rclcpp_lifecycle::State& previous_state)
{
    RCLCPP_INFO(
        this->get_logger(), 
        "Cleaning up from [%s] state...", 
        previous_state.label().c_str()
    );
    
    try {
        // Reset timers
        if (processing_timer_timer_) {
            processing_timer_timer_->cancel();
            processing_timer_timer_.reset();
            processing_timer_was_active_ = false;
        }
        
        // Reset publishers
        if (vision_processed_image_pub_) {
            vision_processed_image_pub_.reset();
        }
        if (vision_detected_objects_pub_) {
            vision_detected_objects_pub_.reset();
        }
        if (vision_face_embeddings_pub_) {
            vision_face_embeddings_pub_.reset();
        }
        if (vision_human_poses_pub_) {
            vision_human_poses_pub_.reset();
        }
        if (vision_depth_map_pub_) {
            vision_depth_map_pub_.reset();
        }
        if (vision_optical_flow_pub_) {
            vision_optical_flow_pub_.reset();
        }
        if (vision_feature_matches_pub_) {
            vision_feature_matches_pub_.reset();
        }
        if (vision_edge_map_pub_) {
            vision_edge_map_pub_.reset();
        }
        
        // Reset subscribers
        if (camera_image_raw_sub_) {
            camera_image_raw_sub_.reset();
        }
        if (camera_camera_info_sub_) {
            camera_camera_info_sub_.reset();
        }
        if (camera2_image_raw_sub_) {
            camera2_image_raw_sub_.reset();
        }
        if (camera2_camera_info_sub_) {
            camera2_camera_info_sub_.reset();
        }
        
        // Reset services
        
        RCLCPP_INFO(this->get_logger(), "Node cleanup completed successfully");
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;
        
    } catch (const std::exception& e) {
        RCLCPP_ERROR(
            this->get_logger(), 
            "Cleanup failed: %s", 
            e.what()
        );
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::ERROR;
    }
}

rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
Vision_processorNode::on_shutdown(const rclcpp_lifecycle::State& previous_state)
{
    RCLCPP_INFO(
        this->get_logger(), 
        "Shutting down from [%s] state...", 
        previous_state.label().c_str()
    );
    
    try {
        // Call cleanup first
        on_cleanup(previous_state);
        
        RCLCPP_INFO(this->get_logger(), "Node shutdown completed successfully");
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;
        
    } catch (const std::exception& e) {
        RCLCPP_ERROR(
            this->get_logger(), 
            "Shutdown failed: %s", 
            e.what()
        );
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::ERROR;
    }
}

// Timer callbacks
void Vision_processorNode::on_processing_timer()
{
    RCLCPP_DEBUG(this->get_logger(), "Timer processing_timer triggered");
    
    // Processing timer implementation
    if (enable_processing_) {
        // Process latest data
        RCLCPP_DEBUG(this->get_logger(), "Processing latest data");
    }
}

// Subscriber callbacks
void Vision_processorNode::on_camera_image_raw(const sensor_msgs::msg::Image::ConstSharedPtr msg)
{
    latest_camera_image_raw_ = msg;
    
    RCLCPP_DEBUG(this->get_logger(), "Received message on /camera/image_raw");
}
void Vision_processorNode::on_camera_camera_info(const sensor_msgs::msg::CameraInfo::ConstSharedPtr msg)
{
    latest_camera_camera_info_ = msg;
    
    RCLCPP_DEBUG(this->get_logger(), "Received message on /camera/camera_info");
}
void Vision_processorNode::on_camera2_image_raw(const sensor_msgs::msg::Image::ConstSharedPtr msg)
{
    latest_camera2_image_raw_ = msg;
    
    RCLCPP_DEBUG(this->get_logger(), "Received message on /camera2/image_raw");
}
void Vision_processorNode::on_camera2_camera_info(const sensor_msgs::msg::CameraInfo::ConstSharedPtr msg)
{
    latest_camera2_camera_info_ = msg;
    
    RCLCPP_DEBUG(this->get_logger(), "Received message on /camera2/camera_info");
}

// Service callbacks



// User-defined C++ methods


int main(int argc, char* argv[])
{
    rclcpp::init(argc, argv);
    auto node = std::make_shared<Vision_processorNode>();
    rclcpp::executors::MultiThreadedExecutor executor;
    executor.add_node(node->get_node_base_interface());
    executor.spin();
    rclcpp::shutdown();
    return 0;
}

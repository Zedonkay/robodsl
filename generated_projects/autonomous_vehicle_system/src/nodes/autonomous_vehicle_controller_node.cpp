// Generated by RoboDSL - DO NOT EDIT

#include "nodes/autonomous_vehicle_controller_node.hpp"
#include <memory>
#include <vector>
#include <map>
#include <cmath>
#include <stdexcept>



Autonomous_vehicle_controllerNode::Autonomous_vehicle_controllerNode(const rclcpp::NodeOptions& options)
: rclcpp_lifecycle::LifecycleNode("autonomous_vehicle_controller", options)
{
    // Initialize parameters
    this->declare_parameter<double>("control_frequency", 100.0);
    this->declare_parameter<double>("perception_frequency", 30.0);
    this->declare_parameter<double>("planning_frequency", 10.0);
    this->declare_parameter<double>("max_velocity", 30.0);
    this->declare_parameter<double>("max_acceleration", 3.0);
    this->declare_parameter<double>("safety_distance", 2.0);
    this->declare_parameter<double>("time_to_collision_threshold", 3.0);
    this->declare_parameter<std::string>("traffic_sign_detector_path", "traffic_sign_detector.onnx");
    this->declare_parameter<std::string>("lane_detector_path", "lane_detector.onnx");
    this->declare_parameter<std::string>("behavior_predictor_path", "behavior_predictor.onnx");

    // Create publishers
    {
        rclcpp::QoS qos(10);
        vehicle_control_command_pub_ = this->create_publisher<std_msgs::msg::Float64MultiArray>(
            "/vehicle/control_command", qos);
    }
    {
        rclcpp::QoS qos(10);
        vehicle_trajectory_pub_ = this->create_publisher<std_msgs::msg::Float64MultiArray>(
            "/vehicle/trajectory", qos);
    }
    {
        rclcpp::QoS qos(10);
        perception_fused_objects_pub_ = this->create_publisher<std_msgs::msg::Float64MultiArray>(
            "/perception/fused_objects", qos);
    }
    {
        rclcpp::QoS qos(10);
        perception_traffic_signs_pub_ = this->create_publisher<std_msgs::msg::Float64MultiArray>(
            "/perception/traffic_signs", qos);
    }
    {
        rclcpp::QoS qos(10);
        perception_lane_markings_pub_ = this->create_publisher<sensor_msgs::msg::Image>(
            "/perception/lane_markings", qos);
    }
    {
        rclcpp::QoS qos(10);
        safety_emergency_stop_pub_ = this->create_publisher<std_msgs::msg::Bool>(
            "/safety/emergency_stop", qos);
    }

    // Create subscribers
    {
        rclcpp::QoS qos(10);
        auto callback = std::bind(
            &Autonomous_vehicle_controllerNode::on_sensor_lidar_points, 
            this, 
            std::placeholders::_1
        );
        sensor_lidar_points_sub_ = this->create_subscription<sensor_msgs::msg::PointCloud2>(
            "/sensor/lidar/points", 
            qos, 
            callback
        );
    }
    {
        rclcpp::QoS qos(10);
        auto callback = std::bind(
            &Autonomous_vehicle_controllerNode::on_sensor_camera_front_image, 
            this, 
            std::placeholders::_1
        );
        sensor_camera_front_image_sub_ = this->create_subscription<sensor_msgs::msg::Image>(
            "/sensor/camera/front/image", 
            qos, 
            callback
        );
    }
    {
        rclcpp::QoS qos(10);
        auto callback = std::bind(
            &Autonomous_vehicle_controllerNode::on_sensor_imu_data, 
            this, 
            std::placeholders::_1
        );
        sensor_imu_data_sub_ = this->create_subscription<sensor_msgs::msg::Imu>(
            "/sensor/imu/data", 
            qos, 
            callback
        );
    }
    {
        rclcpp::QoS qos(10);
        auto callback = std::bind(
            &Autonomous_vehicle_controllerNode::on_vehicle_kinematic_state, 
            this, 
            std::placeholders::_1
        );
        vehicle_kinematic_state_sub_ = this->create_subscription<std_msgs::msg::Float64MultiArray>(
            "/vehicle/kinematic_state", 
            qos, 
            callback
        );
    }

    // Create services
    

    // Create timers
    control_timer_timer_ = this->create_wall_timer(
        std::chrono::duration<double>(1.0),
        std::bind(&Autonomous_vehicle_controllerNode::on_control_timer, this)
    );
    perception_timer_timer_ = this->create_wall_timer(
        std::chrono::duration<double>(1.0),
        std::bind(&Autonomous_vehicle_controllerNode::on_perception_timer, this)
    );
    planning_timer_timer_ = this->create_wall_timer(
        std::chrono::duration<double>(1.0),
        std::bind(&Autonomous_vehicle_controllerNode::on_planning_timer, this)
    );

}

Autonomous_vehicle_controllerNode::~Autonomous_vehicle_controllerNode()
{
}

// Lifecycle callbacks
rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
Autonomous_vehicle_controllerNode::on_configure(const rclcpp_lifecycle::State& previous_state)
{
    RCLCPP_INFO(
        this->get_logger(), 
        "Configuring from [%s] state...", 
        previous_state.label().c_str()
    );
    
    try {
        // Load parameters
        {
            rclcpp::Parameter param;
            if (this->get_parameter("control_frequency", param)) {
                control_frequency_ = param.as_double();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("perception_frequency", param)) {
                perception_frequency_ = param.as_double();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("planning_frequency", param)) {
                planning_frequency_ = param.as_double();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("max_velocity", param)) {
                max_velocity_ = param.as_double();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("max_acceleration", param)) {
                max_acceleration_ = param.as_double();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("safety_distance", param)) {
                safety_distance_ = param.as_double();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("time_to_collision_threshold", param)) {
                time_to_collision_threshold_ = param.as_double();
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("traffic_sign_detector_path", param)) {
                // Parameter traffic_sign_detector_path of type string not supported
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("lane_detector_path", param)) {
                // Parameter lane_detector_path of type string not supported
            }
        }
        {
            rclcpp::Parameter param;
            if (this->get_parameter("behavior_predictor_path", param)) {
                // Parameter behavior_predictor_path of type string not supported
            }
        }
        
        RCLCPP_INFO(this->get_logger(), "Configuration completed successfully");
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;
        
    } catch (const std::exception& e) {
        RCLCPP_ERROR(
            this->get_logger(), 
            "Configuration failed: %s", 
            e.what()
        );
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::FAILURE;
    }
}

rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
Autonomous_vehicle_controllerNode::on_activate(const rclcpp_lifecycle::State& previous_state)
{
    RCLCPP_INFO(
        this->get_logger(), 
        "Activating from [%s] state...", 
        previous_state.label().c_str()
    );
    
    try {
        // Activate publishers
        if (vehicle_control_command_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<std_msgs::msg::Float64MultiArray>>(vehicle_control_command_pub_);
            if (pub) {
                pub->on_activate();
            }
        }
        if (vehicle_trajectory_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<std_msgs::msg::Float64MultiArray>>(vehicle_trajectory_pub_);
            if (pub) {
                pub->on_activate();
            }
        }
        if (perception_fused_objects_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<std_msgs::msg::Float64MultiArray>>(perception_fused_objects_pub_);
            if (pub) {
                pub->on_activate();
            }
        }
        if (perception_traffic_signs_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<std_msgs::msg::Float64MultiArray>>(perception_traffic_signs_pub_);
            if (pub) {
                pub->on_activate();
            }
        }
        if (perception_lane_markings_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<sensor_msgs::msg::Image>>(perception_lane_markings_pub_);
            if (pub) {
                pub->on_activate();
            }
        }
        if (safety_emergency_stop_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<std_msgs::msg::Bool>>(safety_emergency_stop_pub_);
            if (pub) {
                pub->on_activate();
            }
        }
        
        // Mark node as active
        is_active_ = true;
        
        RCLCPP_INFO(this->get_logger(), "Node activated successfully");
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;
        
    } catch (const std::exception& e) {
        RCLCPP_ERROR(
            this->get_logger(), 
            "Activation failed: %s", 
            e.what()
        );
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::FAILURE;
    }
}

rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
Autonomous_vehicle_controllerNode::on_deactivate(const rclcpp_lifecycle::State& previous_state)
{
    RCLCPP_INFO(
        this->get_logger(), 
        "Deactivating from [%s] state...", 
        previous_state.label().c_str()
    );
    
    try {
        // Mark node as inactive
        is_active_ = false;
        
        // Stop timers
        if (control_timer_timer_) {
            control_timer_was_active_ = !control_timer_timer_->is_canceled();
            if (control_timer_was_active_) {
                control_timer_timer_->cancel();
            }
        }
        if (perception_timer_timer_) {
            perception_timer_was_active_ = !perception_timer_timer_->is_canceled();
            if (perception_timer_was_active_) {
                perception_timer_timer_->cancel();
            }
        }
        if (planning_timer_timer_) {
            planning_timer_was_active_ = !planning_timer_timer_->is_canceled();
            if (planning_timer_was_active_) {
                planning_timer_timer_->cancel();
            }
        }
        
        // Deactivate publishers
        if (vehicle_control_command_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<std_msgs::msg::Float64MultiArray>>(vehicle_control_command_pub_);
            if (pub && pub->is_activated()) {
                pub->on_deactivate();
            }
        }
        if (vehicle_trajectory_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<std_msgs::msg::Float64MultiArray>>(vehicle_trajectory_pub_);
            if (pub && pub->is_activated()) {
                pub->on_deactivate();
            }
        }
        if (perception_fused_objects_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<std_msgs::msg::Float64MultiArray>>(perception_fused_objects_pub_);
            if (pub && pub->is_activated()) {
                pub->on_deactivate();
            }
        }
        if (perception_traffic_signs_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<std_msgs::msg::Float64MultiArray>>(perception_traffic_signs_pub_);
            if (pub && pub->is_activated()) {
                pub->on_deactivate();
            }
        }
        if (perception_lane_markings_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<sensor_msgs::msg::Image>>(perception_lane_markings_pub_);
            if (pub && pub->is_activated()) {
                pub->on_deactivate();
            }
        }
        if (safety_emergency_stop_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<std_msgs::msg::Bool>>(safety_emergency_stop_pub_);
            if (pub && pub->is_activated()) {
                pub->on_deactivate();
            }
        }
        
        RCLCPP_INFO(this->get_logger(), "Node deactivated successfully");
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;
        
    } catch (const std::exception& e) {
        RCLCPP_ERROR(
            this->get_logger(), 
            "Deactivation failed: %s", 
            e.what()
        );
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::FAILURE;
    }
}

rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
Autonomous_vehicle_controllerNode::on_cleanup(const rclcpp_lifecycle::State& previous_state)
{
    RCLCPP_INFO(
        this->get_logger(), 
        "Cleaning up from [%s] state...", 
        previous_state.label().c_str()
    );
    
    try {
        // Reset timers
        if (control_timer_timer_) {
            control_timer_timer_->cancel();
            control_timer_timer_.reset();
            control_timer_was_active_ = false;
        }
        if (perception_timer_timer_) {
            perception_timer_timer_->cancel();
            perception_timer_timer_.reset();
            perception_timer_was_active_ = false;
        }
        if (planning_timer_timer_) {
            planning_timer_timer_->cancel();
            planning_timer_timer_.reset();
            planning_timer_was_active_ = false;
        }
        
        // Reset publishers
        if (vehicle_control_command_pub_) {
            vehicle_control_command_pub_.reset();
        }
        if (vehicle_trajectory_pub_) {
            vehicle_trajectory_pub_.reset();
        }
        if (perception_fused_objects_pub_) {
            perception_fused_objects_pub_.reset();
        }
        if (perception_traffic_signs_pub_) {
            perception_traffic_signs_pub_.reset();
        }
        if (perception_lane_markings_pub_) {
            perception_lane_markings_pub_.reset();
        }
        if (safety_emergency_stop_pub_) {
            safety_emergency_stop_pub_.reset();
        }
        
        // Reset subscribers
        if (sensor_lidar_points_sub_) {
            sensor_lidar_points_sub_.reset();
        }
        if (sensor_camera_front_image_sub_) {
            sensor_camera_front_image_sub_.reset();
        }
        if (sensor_imu_data_sub_) {
            sensor_imu_data_sub_.reset();
        }
        if (vehicle_kinematic_state_sub_) {
            vehicle_kinematic_state_sub_.reset();
        }
        
        // Reset services
        
        RCLCPP_INFO(this->get_logger(), "Node cleanup completed successfully");
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;
        
    } catch (const std::exception& e) {
        RCLCPP_ERROR(
            this->get_logger(), 
            "Cleanup failed: %s", 
            e.what()
        );
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::ERROR;
    }
}

rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
Autonomous_vehicle_controllerNode::on_shutdown(const rclcpp_lifecycle::State& previous_state)
{
    RCLCPP_INFO(
        this->get_logger(), 
        "Shutting down from [%s] state...", 
        previous_state.label().c_str()
    );
    
    try {
        // Call cleanup first
        on_cleanup(previous_state);
        
        RCLCPP_INFO(this->get_logger(), "Node shutdown completed successfully");
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;
        
    } catch (const std::exception& e) {
        RCLCPP_ERROR(
            this->get_logger(), 
            "Shutdown failed: %s", 
            e.what()
        );
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::ERROR;
    }
}

// Timer callbacks
void Autonomous_vehicle_controllerNode::on_control_timer()
{
    RCLCPP_DEBUG(this->get_logger(), "Timer control_timer triggered");
    
    // Custom timer implementation
    RCLCPP_DEBUG(this->get_logger(), "Custom timer control_timer executed");
}
void Autonomous_vehicle_controllerNode::on_perception_timer()
{
    RCLCPP_DEBUG(this->get_logger(), "Timer perception_timer triggered");
    
    // Custom timer implementation
    RCLCPP_DEBUG(this->get_logger(), "Custom timer perception_timer executed");
}
void Autonomous_vehicle_controllerNode::on_planning_timer()
{
    RCLCPP_DEBUG(this->get_logger(), "Timer planning_timer triggered");
    
    // Custom timer implementation
    RCLCPP_DEBUG(this->get_logger(), "Custom timer planning_timer executed");
}

// Subscriber callbacks
void Autonomous_vehicle_controllerNode::on_sensor_lidar_points(const sensor_msgs::msg::PointCloud2::ConstSharedPtr msg)
{
    latest_sensor_lidar_points_ = msg;
    
    RCLCPP_DEBUG(this->get_logger(), "Received message on /sensor/lidar/points");
}
void Autonomous_vehicle_controllerNode::on_sensor_camera_front_image(const sensor_msgs::msg::Image::ConstSharedPtr msg)
{
    latest_sensor_camera_front_image_ = msg;
    
    RCLCPP_DEBUG(this->get_logger(), "Received message on /sensor/camera/front/image");
}
void Autonomous_vehicle_controllerNode::on_sensor_imu_data(const sensor_msgs::msg::Imu::ConstSharedPtr msg)
{
    latest_sensor_imu_data_ = msg;
    
    RCLCPP_DEBUG(this->get_logger(), "Received message on /sensor/imu/data");
}
void Autonomous_vehicle_controllerNode::on_vehicle_kinematic_state(const std_msgs::msg::Float64MultiArray::ConstSharedPtr msg)
{
    latest_vehicle_kinematic_state_ = msg;
    
    RCLCPP_DEBUG(this->get_logger(), "Received message on /vehicle/kinematic_state");
}

// Service callbacks



// User-defined C++ methods


int main(int argc, char* argv[])
{
    rclcpp::init(argc, argv);
    auto node = std::make_shared<Autonomous_vehicle_controllerNode>();
    rclcpp::executors::MultiThreadedExecutor executor;
    executor.add_node(node->get_node_base_interface());
    executor.spin();
    rclcpp::shutdown();
    return 0;
}

// Generated by RoboDSL - DO NOT EDIT

#include "{{ include_path }}"
#include <memory>
#include <vector>
#include <map>
#include <cmath>
#include <stdexcept>

{% if global_cpp_code %}
// Global C++ code blocks (passed through as-is)
{% for cpp_block in global_cpp_code %}
{{ cpp_block.code | dedent }}
{% endfor %}
{% endif %}

{% if namespace %}
namespace {{ namespace }} {
{% endif %}

{{ class_name }}::{{ class_name }}(const rclcpp::NodeOptions& options)
: {{ base_class }}("{{ node_name }}", options)
{
    // Initialize parameters
    {% for param in parameters %}
    this->declare_parameter<{{ param.template_type }}>("{{ param.name }}", {{ param.default_value }});
    {% endfor %}

    // Create publishers
    {% for pub in publishers %}
    {
        rclcpp::QoS qos({{ pub.qos.depth | default(10) }});
        {% if pub.qos.reliability %}
        {% if pub.qos.reliability == 'reliable' %}
        qos.reliability(rclcpp::ReliabilityPolicy::Reliable);
        {% elif pub.qos.reliability == 'best_effort' %}
        qos.reliability(rclcpp::ReliabilityPolicy::BestEffort);
        {% endif %}
        {% endif %}
        {% if pub.qos.durability %}
        qos.durability(rclcpp::{{ pub.qos.durability }});
        {% endif %}
        {{ pub.name }}_pub_ = this->create_publisher<{{ pub.msg_type }}>(
            "{{ pub.topic }}", qos);
    }
    {% endfor %}

    // Create subscribers
    {% for sub in subscribers %}
    {
        rclcpp::QoS qos({{ sub.qos.depth | default(10) }});
        {% if sub.qos.reliability %}
        {% if sub.qos.reliability == 'reliable' %}
        qos.reliability(rclcpp::ReliabilityPolicy::Reliable);
        {% elif sub.qos.reliability == 'best_effort' %}
        qos.reliability(rclcpp::ReliabilityPolicy::BestEffort);
        {% endif %}
        {% endif %}
        auto callback = std::bind(
            &{{ class_name }}::{{ sub.callback_name }}, 
            this, 
            std::placeholders::_1
        );
        {{ sub.name }}_sub_ = this->create_subscription<{{ sub.msg_type }}>(
            "{{ sub.topic }}", 
            qos, 
            callback
        );
    }
    {% endfor %}

    // Create services
    {% for srv in services %}
    {
        auto callback = [this](
            const std::shared_ptr<{{ srv.srv_type }}::Request> request,
            std::shared_ptr<{{ srv.srv_type }}::Response> response
        ) {
            this->{{ srv.callback_name }}(request, response);
        };
        
        {{ srv.name }}_srv_ = this->create_service<{{ srv.srv_type }}>(
            "{{ srv.service }}", 
            callback
        );
    }
    {% endfor %}
    
    {% if actions %}
    // Initialize action servers
    {% for action in actions %}
    {
        using namespace std::placeholders;
        
        auto handle_goal = [this](
            const rclcpp_action::GoalUUID& uuid,
            std::shared_ptr<const {{ action.action_type }}::Goal> goal
        ) -> rclcpp_action::GoalResponse {
            RCLCPP_INFO(this->get_logger(), 
                "Received goal request for action {{ action.name }}");
            (void)uuid;
            (void)goal;
            return rclcpp_action::GoalResponse::ACCEPT_AND_EXECUTE;
        };
        
        auto handle_cancel = [this](
            const std::shared_ptr<rclcpp_action::ServerGoalHandle<{{ action.action_type }}>> goal_handle
        ) -> rclcpp_action::CancelResponse {
            RCLCPP_INFO(this->get_logger(), 
                "Received request to cancel goal for action {{ action.name }}");
            (void)goal_handle;
            return rclcpp_action::CancelResponse::ACCEPT;
        };
        
        auto handle_accepted = [this](
            const std::shared_ptr<rclcpp_action::ServerGoalHandle<{{ action.action_type }}>> goal_handle
        ) {
            std::thread{
                std::bind(&{{ class_name }}::execute_{{ action.name | replace('/', '_') }}, this, _1), 
                goal_handle
            }.detach();
        };
        
        {{ action.name | replace('/', '_') }}_action_server_ = rclcpp_action::create_server<{{ action.action_type }}>(
            this->get_node_base_interface(),
            this->get_node_clock_interface(),
            this->get_node_logging_interface(),
            this->get_node_waitables_interface(),
            "{{ action.topic }}",
            handle_goal,
            handle_cancel,
            handle_accepted
        );
    }
    {% endfor %}
    {% endif %}

    // Create timers
    {% for timer in timers %}
    {{ timer.name }}_timer_ = this->create_wall_timer(
        std::chrono::duration<double>({{ timer.period }}),
        std::bind(&{{ class_name }}::{{ timer.callback_name }}, this)
    );
    {% endfor %}

    {% if cuda_kernels %}
    // Initialize CUDA if enabled
    if (enable_processing_) {
        initializeCuda();
    }
    {% endif %}
}

{{ class_name }}::~{{ class_name }}()
{
    {% if cuda_kernels %}
    // Clean up CUDA resources
    cleanupCuda();
    {% endif %}
}

{% if is_lifecycle %}
// Lifecycle callbacks
rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
{{ class_name }}::on_configure(const rclcpp_lifecycle::State& previous_state)
{
    RCLCPP_INFO(
        this->get_logger(), 
        "Configuring from [%s] state...", 
        previous_state.label().c_str()
    );
    
    try {
        // Load parameters
        {% for param in parameters %}
        {
            rclcpp::Parameter param;
            if (this->get_parameter("{{ param.name }}", param)) {
                {% if param.type == 'int' %}
                {{ param.name }}_ = param.as_int();
                {% elif param.type == 'double' %}
                {{ param.name }}_ = param.as_double();
                {% elif param.type == 'bool' %}
                {{ param.name }}_ = param.as_bool();
                {% elif param.type == 'std::string' %}
                {{ param.name }}_ = param.as_string();
                {% elif param.type.startswith('std::vector<int>') %}
                {{ param.name }}_ = param.as_integer_array();
                {% elif param.type.startswith('std::vector<double>') %}
                {{ param.name }}_ = param.as_double_array();
                {% elif param.type.startswith('std::vector<std::string>') %}
                {{ param.name }}_ = param.as_string_array();
                {% else %}
                // Parameter {{ param.name }} of type {{ param.type }} not supported
                {% endif %}
            }
        }
        {% endfor %}
        
        RCLCPP_INFO(this->get_logger(), "Configuration completed successfully");
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;
        
    } catch (const std::exception& e) {
        RCLCPP_ERROR(
            this->get_logger(), 
            "Configuration failed: %s", 
            e.what()
        );
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::FAILURE;
    }
}

rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
{{ class_name }}::on_activate(const rclcpp_lifecycle::State& previous_state)
{
    RCLCPP_INFO(
        this->get_logger(), 
        "Activating from [%s] state...", 
        previous_state.label().c_str()
    );
    
    try {
        // Activate publishers
        {% for pub in publishers %}
        if ({{ pub.name }}_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<{{ pub.msg_type }}>>({{ pub.name }}_pub_);
            if (pub) {
                pub->on_activate();
            }
        }
        {% endfor %}
        
        // Mark node as active
        is_active_ = true;
        
        RCLCPP_INFO(this->get_logger(), "Node activated successfully");
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;
        
    } catch (const std::exception& e) {
        RCLCPP_ERROR(
            this->get_logger(), 
            "Activation failed: %s", 
            e.what()
        );
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::FAILURE;
    }
}

rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
{{ class_name }}::on_deactivate(const rclcpp_lifecycle::State& previous_state)
{
    RCLCPP_INFO(
        this->get_logger(), 
        "Deactivating from [%s] state...", 
        previous_state.label().c_str()
    );
    
    try {
        // Mark node as inactive
        is_active_ = false;
        
        // Stop timers
        {% for timer in timers %}
        if ({{ timer.name }}_timer_) {
            {{ timer.name }}_was_active_ = !{{ timer.name }}_timer_->is_canceled();
            if ({{ timer.name }}_was_active_) {
                {{ timer.name }}_timer_->cancel();
            }
        }
        {% endfor %}
        
        // Deactivate publishers
        {% for pub in publishers %}
        if ({{ pub.name }}_pub_) {
            auto pub = std::dynamic_pointer_cast<rclcpp_lifecycle::LifecyclePublisher<{{ pub.msg_type }}>>({{ pub.name }}_pub_);
            if (pub && pub->is_activated()) {
                pub->on_deactivate();
            }
        }
        {% endfor %}
        
        RCLCPP_INFO(this->get_logger(), "Node deactivated successfully");
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;
        
    } catch (const std::exception& e) {
        RCLCPP_ERROR(
            this->get_logger(), 
            "Deactivation failed: %s", 
            e.what()
        );
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::FAILURE;
    }
}

rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
{{ class_name }}::on_cleanup(const rclcpp_lifecycle::State& previous_state)
{
    RCLCPP_INFO(
        this->get_logger(), 
        "Cleaning up from [%s] state...", 
        previous_state.label().c_str()
    );
    
    try {
        // Reset timers
        {% for timer in timers %}
        if ({{ timer.name }}_timer_) {
            {{ timer.name }}_timer_->cancel();
            {{ timer.name }}_timer_.reset();
            {{ timer.name }}_was_active_ = false;
        }
        {% endfor %}
        
        // Reset publishers
        {% for pub in publishers %}
        if ({{ pub.name }}_pub_) {
            {{ pub.name }}_pub_.reset();
        }
        {% endfor %}
        
        // Reset subscribers
        {% for sub in subscribers %}
        if ({{ sub.name }}_sub_) {
            {{ sub.name }}_sub_.reset();
        }
        {% endfor %}
        
        // Reset services
        {% for srv in services %}
        if ({{ srv.name }}_srv_) {
            {{ srv.name }}_srv_.reset();
        }
        {% endfor %}
        
        RCLCPP_INFO(this->get_logger(), "Node cleanup completed successfully");
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;
        
    } catch (const std::exception& e) {
        RCLCPP_ERROR(
            this->get_logger(), 
            "Cleanup failed: %s", 
            e.what()
        );
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::ERROR;
    }
}

rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
{{ class_name }}::on_shutdown(const rclcpp_lifecycle::State& previous_state)
{
    RCLCPP_INFO(
        this->get_logger(), 
        "Shutting down from [%s] state...", 
        previous_state.label().c_str()
    );
    
    try {
        // Call cleanup first
        on_cleanup(previous_state);
        
        RCLCPP_INFO(this->get_logger(), "Node shutdown completed successfully");
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;
        
    } catch (const std::exception& e) {
        RCLCPP_ERROR(
            this->get_logger(), 
            "Shutdown failed: %s", 
            e.what()
        );
        return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::ERROR;
    }
}
{% endif %}

// Timer callbacks
{% for timer in timers %}
void {{ class_name }}::{{ timer.callback_name }}()
{
    RCLCPP_DEBUG(this->get_logger(), "Timer {{ timer.name }} triggered");
    
    {% if timer.name == 'main_timer' %}
    // Main timer implementation
    auto message = std_msgs::msg::String();
    message.data = "Hello from {{ node_name }}! Count: " + std::to_string(count_);
    chatter_pub_->publish(message);
    count_++;
    {% elif timer.name == 'processing_timer' %}
    // Processing timer implementation
    if (enable_processing_) {
        // Process latest data
        RCLCPP_DEBUG(this->get_logger(), "Processing latest data");
    }
    {% else %}
    // Custom timer implementation
    RCLCPP_DEBUG(this->get_logger(), "Custom timer {{ timer.name }} executed");
    {% endif %}
}
{% endfor %}

// Subscriber callbacks
{% for sub in subscribers %}
void {{ class_name }}::{{ sub.callback_name }}(const {{ sub.msg_type }}::ConstSharedPtr msg)
{
    {% if sub.msg_type == 'sensor_msgs::msg::Image' %}
    latest_image_ = msg;
    {% elif sub.msg_type == 'sensor_msgs::msg::PointCloud2' %}
    latest_pointcloud_ = msg;
    {% elif sub.msg_type == 'geometry_msgs::msg::Twist' %}
    latest_twist_ = msg;
    {% elif sub.msg_type == 'sensor_msgs::msg::LaserScan' %}
    latest_scan_ = msg;
    {% endif %}
    
    RCLCPP_DEBUG(this->get_logger(), "Received message on {{ sub.topic }}");
}
{% endfor %}

// Service callbacks
{% for srv in services %}
void {{ class_name }}::{{ srv.callback_name }}(
    const std::shared_ptr<{{ srv.srv_type }}::Request> request,
    std::shared_ptr<{{ srv.srv_type }}::Response> response)
{
    RCLCPP_DEBUG(this->get_logger(), "Service {{ srv.service }} called");
    
    // Default service implementation
    response->success = true;
    response->message = "Service {{ srv.service }} completed successfully";
}
{% endfor %}

{% if actions %}
// Action callbacks
{% for action in actions %}
void {{ class_name }}::execute_{{ action.name | replace('/', '_') }}(
    const std::shared_ptr<rclcpp_action::ServerGoalHandle<{{ action.action_type }}>> goal_handle)
{
    RCLCPP_INFO(this->get_logger(), "Executing action {{ action.name }}");
    
    const auto goal = goal_handle->get_goal();
    auto feedback = std::make_shared<{{ action.action_type }}::Feedback>();
    auto result = std::make_shared<{{ action.action_type }}::Result>();
    
    // Action implementation
    result->success = true;
    goal_handle->succeed(result);
}
{% endfor %}
{% endif %}

{% if cuda_kernels %}
// CUDA methods
bool {{ class_name }}::initializeCuda() {
    RCLCPP_DEBUG(this->get_logger(), "Initializing CUDA resources");
    try {
        // Initialize CUDA device
        cudaError_t status = cudaSetDevice(cuda_device_id_);
        if (status != cudaSuccess) {
            RCLCPP_ERROR(this->get_logger(), 
                       "Failed to set CUDA device %d: %s", 
                       cuda_device_id_, 
                       cudaGetErrorString(status));
            return false;
        }
        
        // Get and log device properties
        cudaDeviceProp props;
        status = cudaGetDeviceProperties(&props, cuda_device_id_);
        if (status == cudaSuccess) {
            RCLCPP_INFO(this->get_logger(), 
                      "Using CUDA device %d: %s (Compute %d.%d)",
                      cuda_device_id_, 
                      props.name, 
                      props.major, 
                      props.minor);
        }
        
        return true;
    } catch (const std::exception& e) {
        RCLCPP_ERROR(this->get_logger(), 
                   "Exception during CUDA initialization: %s", 
                   e.what());
        return false;
    }
}

void {{ class_name }}::cleanupCuda() {
    RCLCPP_DEBUG(this->get_logger(), "Cleaning up CUDA resources");
    try {
        // Synchronize and reset the device
        cudaDeviceSynchronize();
        cudaDeviceReset();
    } catch (const std::exception& e) {
        RCLCPP_ERROR(this->get_logger(), 
                   "Exception during CUDA cleanup: %s", 
                   e.what());
    }
}

std::vector<float> {{ class_name }}::processWithCuda(
    const std::vector<float>& input,
    const CudaParams& parameters)
{
    RCLCPP_DEBUG(this->get_logger(), "Default processWithCuda implementation called");
    // Default implementation returns an empty vector
    return {};
}

// CUDA kernel wrappers
{% for kernel in cuda_kernels %}
std::vector<float> {{ class_name }}::call_{{ kernel.name }}_kernel(
    const std::vector<float>& input,
    const {{ kernel.struct_name }}& parameters)
{
    RCLCPP_DEBUG(this->get_logger(), "CUDA kernel {{ kernel.name }} called with %zu elements", input.size());
    
    // Default implementation returns an empty vector
    // Override this method in derived classes to provide actual CUDA kernel execution
    return std::vector<float>();
}
{% endfor %}
{% endif %}

// User-defined C++ methods
{% for method in cpp_methods %}
void {{ class_name }}::{{ method.name }}(
    {% set valid_inputs = [] -%}
    {%- for input in method.inputs -%}
        {%- if input.type != 'void' -%}
            {%- set _ = valid_inputs.append(input) -%}
        {%- endif -%}
    {%- endfor -%}
    {% for input in valid_inputs %}{{ input.type }} {{ input.name }}{% if not loop.last %}, {% endif %}{% endfor %}
    {% if valid_inputs and method.outputs %}, {% endif %}
    {% for output in method.outputs %}{{ output.type }}& {{ output.name }}{% if not loop.last %}, {% endif %}{% endfor %}
) {
{% if method.outputs %}
    // Method has output parameters
    {% for output in method.outputs %}
    {{ output.name }} = {};  // Default initialization
    {% endfor %}
{% else %}
    // Method implementation
    {% if method.code and method.code.strip() %}
{{ method.code | indent(4) }}
    {% else %}
    // TODO: Implement method logic
    RCLCPP_DEBUG(this->get_logger(), "Method {{ method.name }} called");
    
    // Common method implementations
    {% if method.name == 'process_safety_check' %}
    // Safety check implementation
    if (latest_twist_) {
        // Check velocity limits
        RCLCPP_DEBUG(this->get_logger(), "Safety check passed");
    }
    {% elif method.name == 'process_navigation_step' %}
    // Navigation step implementation
    RCLCPP_DEBUG(this->get_logger(), "Navigation step executed");
    {% elif method.name == 'process_image' %}
    // Image processing implementation
    if (latest_image_) {
        RCLCPP_DEBUG(this->get_logger(), "Processing image");
        // Add image processing logic here
    }
    {% elif method.name == 'process_image_gpu' %}
    // GPU image processing implementation
    RCLCPP_DEBUG(this->get_logger(), "Processing image with GPU");
    // Add GPU image processing logic here
    {% elif method.name == 'run_detection_inference' %}
    // Detection inference implementation
    RCLCPP_DEBUG(this->get_logger(), "Running detection inference");
    // Add detection inference logic here
    {% endif %}
    {% endif %}
{% endif %}
}
{% endfor %}

{% if namespace %}
} // namespace {{ namespace }}
{% endif %}

int main(int argc, char* argv[])
{
    rclcpp::init(argc, argv);
    {% if namespace %}
    auto node = std::make_shared<{{ namespace }}::{{ class_name }}>();
    {% else %}
    auto node = std::make_shared<{{ class_name }}>();
    {% endif %}
    {% if is_lifecycle %}
    rclcpp::executors::MultiThreadedExecutor executor;
    executor.add_node(node->get_node_base_interface());
    executor.spin();
    {% else %}
    rclcpp::spin(node);
    {% endif %}
    rclcpp::shutdown();
    return 0;
}

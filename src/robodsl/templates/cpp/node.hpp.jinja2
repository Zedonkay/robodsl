// Generated by RoboDSL - DO NOT EDIT

#ifndef {{ include_guard }}
#define {{ include_guard }}

// Standard includes
#include <memory>
#include <string>
#include <vector>
#include <map>
#include <cmath>
#include <functional>
#include <thread>
#include <atomic>

// ROS2 includes
#include <rclcpp/rclcpp.hpp>
{% if is_lifecycle %}
#include <rclcpp_lifecycle/lifecycle_node.hpp>
#include <rclcpp_lifecycle/lifecycle_publisher.hpp>
#include <rclcpp_lifecycle/node_interfaces/lifecycle_node_interface.hpp>
{% endif %}
{% if actions %}
#include <rclcpp_action/rclcpp_action.hpp>
{% endif %}
{% if services %}
#include <rclcpp/rclcpp.hpp>
{% endif %}

// Message includes
{% for include in includes %}
{{ include }}
{% endfor %}

// Additional ROS2 includes
{% for include in ros2_includes %}
{{ include }}
{% endfor %}

// CUDA includes (if needed)
{% if cuda_kernels %}
#include <cuda_runtime.h>
#include <device_launch_parameters.h>
{% endif %}

// OpenCV includes (if needed)
{% if opencv_needed %}
#include <opencv2/opencv.hpp>
#include <cv_bridge/cv_bridge.h>
{% endif %}

// Type definitions
#ifndef __UCHAR_TYPE__
typedef unsigned char uchar;
#endif

// Forward declarations for custom types
{% if custom_types %}
{% for type in custom_types %}
struct {{ type.name }} {
    {% for field in type.fields %}
    {{ field.type }} {{ field.name }}{% if field.default_value %} = {{ field.default_value }}{% endif %};
    {% endfor %}
};
{% endfor %}
{% endif %}

// CUDA parameter structs
{% if cuda_kernels %}
{% for kernel in cuda_kernels %}
struct {{ kernel.struct_name }} {
    {% for param in kernel.parameters %}
    {{ param.type }} {{ param.name }};
    {% endfor %}
};
{% endfor %}
{% endif %}

{% if namespace %}
namespace {{ namespace }} {
{% endif %}

class {{ class_name }} : public {{ base_class }} {
public:
    explicit {{ class_name }}(const rclcpp::NodeOptions& options = rclcpp::NodeOptions());
    virtual ~{{ class_name }}();

    {% if is_lifecycle %}
    // Lifecycle callbacks
    rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn 
    on_configure(const rclcpp_lifecycle::State& previous_state) override;
    
    rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn 
    on_activate(const rclcpp_lifecycle::State& previous_state) override;
    
    rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn 
    on_deactivate(const rclcpp_lifecycle::State& previous_state) override;
    
    rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn 
    on_cleanup(const rclcpp_lifecycle::State& previous_state) override;
    
    rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn 
    on_shutdown(const rclcpp_lifecycle::State& previous_state) override;
    {% endif %}

    // Timer callbacks
    {% for timer in timers %}
    void {{ timer.callback_name }}();
    {% endfor %}

    // Subscriber callbacks
    {% for sub in subscribers %}
    void {{ sub.callback_name }}(const {{ sub.msg_type }}::ConstSharedPtr msg);
    {% endfor %}

    // Service callbacks
    {% for srv in services %}
    void {{ srv.callback_name }}(
        const std::shared_ptr<{{ srv.srv_type }}::Request> request,
        std::shared_ptr<{{ srv.srv_type }}::Response> response);
    {% endfor %}

    {% if actions %}
    // Action callbacks
    {% for action in actions %}
    void execute_{{ action.name | replace('/', '_') }}(
        const std::shared_ptr<rclcpp_action::ServerGoalHandle<{{ action.action_type }}>> goal_handle);
    {% endfor %}
    {% endif %}

    {% if cuda_kernels %}
    // CUDA methods
    virtual bool initializeCuda();
    virtual void cleanupCuda();
    virtual std::vector<float> processWithCuda(
        const std::vector<float>& input,
        const CudaParams& parameters);
    
    // CUDA kernel wrappers
    {% for kernel in cuda_kernels %}
    virtual std::vector<float> call_{{ kernel.name }}_kernel(
        const std::vector<float>& input,
        const {{ kernel.struct_name }}& parameters);
    {% endfor %}
    {% endif %}

    // User-defined C++ methods
    {% for method in cpp_methods %}
    void {{ method.name }}(
        {% set valid_inputs = [] -%}
        {%- for input in method.inputs -%}
            {%- if input.type != 'void' -%}
                {%- set _ = valid_inputs.append(input) -%}
            {%- endif -%}
        {%- endfor -%}
        {% for input in valid_inputs %}{{ input.type }} {{ input.name }}{% if not loop.last %}, {% endif %}{% endfor %}
        {% if valid_inputs and method.outputs %}, {% endif %}
        {% for output in method.outputs %}{{ output.type }}& {{ output.name }}{% if not loop.last %}, {% endif %}{% endfor %}
    );
    {% endfor %}

private:
    // Publishers
    {% for pub in publishers %}
    std::shared_ptr<{% if is_lifecycle %}rclcpp_lifecycle::LifecyclePublisher<{{ pub.msg_type }}>{% else %}rclcpp::Publisher<{{ pub.msg_type }}>{% endif %}> {{ pub.name }}_pub_;
    {% endfor %}

    // Subscribers
    {% for sub in subscribers %}
    rclcpp::Subscription<{{ sub.msg_type }}>::SharedPtr {{ sub.name }}_sub_;
    {% endfor %}

    // Services
    {% for srv in services %}
    rclcpp::Service<{{ srv.srv_type }}>::SharedPtr {{ srv.name }}_srv_;
    {% endfor %}

    {% if actions %}
    // Action servers
    {% for action in actions %}
    rclcpp_action::Server<{{ action.action_type }}>::SharedPtr {{ action.name | replace('/', '_') }}_action_server_;
    {% endfor %}
    {% endif %}

    // Timers
    {% for timer in timers %}
    rclcpp::TimerBase::SharedPtr {{ timer.name }}_timer_;
    {% endfor %}

    // Lifecycle state tracking
    {% if is_lifecycle %}
    std::atomic<bool> is_active_{false};
    {% for timer in timers %}
    bool {{ timer.name }}_was_active_{false};
    {% endfor %}
    {% endif %}

    {% if cuda_kernels %}
    // CUDA resources
    int cuda_device_id_{0};
    std::map<std::string, cudaStream_t> cuda_streams_;
    {% endif %}
    
    // Processing control
    bool enable_processing_{true};

    // Parameters
    {% for param in parameters %}
    {% if param.type == 'int' %}
    int {{ param.name }}_;
    {% elif param.type == 'double' %}
    double {{ param.name }}_;
    {% elif param.type == 'bool' %}
    bool {{ param.name }}_;
    {% elif param.type == 'std::string' %}
    std::string {{ param.name }}_;
    {% elif param.type.startswith('std::vector<int>') %}
    std::vector<int> {{ param.name }}_;
    {% elif param.type.startswith('std::vector<double>') %}
    std::vector<double> {{ param.name }}_;
    {% elif param.type.startswith('std::vector<std::string>') %}
    std::vector<std::string> {{ param.name }}_;
    {% else %}
    // Parameter {{ param.name }} of type {{ param.type }} not supported in member variables
    {% endif %}
    {% endfor %}

    // Latest message storage (per-subscriber)
    {% for sub in subscribers %}
    {{ sub.msg_type }}::ConstSharedPtr latest_{{ sub.name }}_;
    {% endfor %}

    // CUDA kernel member variables
    {% for kernel in cuda_kernels %}
    {% for member in kernel.members %}
    {{ member.type }} {{ member.name }}_;
    {% endfor %}
    {% endfor %}

    // Helper methods
    void init_parameters();
    void init_publishers();
    void init_subscribers();
    void init_services();
    {% if actions %}
    void init_action_servers();
    {% endif %}
    void init_timers();
    {% if cuda_kernels %}
    void init_cuda();
    {% endif %}
};

{% if namespace %}
} // namespace {{ namespace }}
{% endif %}

#endif // {{ include_guard }}

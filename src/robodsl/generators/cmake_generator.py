"""CMake Generator for RoboDSL.

This generator creates CMakeLists.txt files for building ROS2 packages.
"""

from pathlib import Path
from typing import Dict, List, Any, Optional

from .base_generator import BaseGenerator
from ..ast import RoboDSLAST, NodeNode, KernelNode


class CMakeGenerator(BaseGenerator):
    """Generates CMake build files."""
    
    def generate(self, ast: RoboDSLAST) -> List[Path]:
        """Generate CMake files from the AST.
        
        Args:
            ast: The parsed RoboDSL AST
            
        Returns:
            List of Path objects for generated files
        """
        generated_files = []
        
        # Generate main CMakeLists.txt
        cmake_path = self._generate_cmake_lists(ast)
        generated_files.append(cmake_path)
        
        # Generate package.xml
        package_xml_path = self._generate_package_xml(ast)
        generated_files.append(package_xml_path)
        
        # Generate build configuration files
        config_path = self._generate_build_config(ast)
        generated_files.append(config_path)
        
        return generated_files
    
    def _generate_cmake_lists(self, ast: RoboDSLAST) -> Path:
        """Generate the main CMakeLists.txt file."""
        context = self._prepare_cmake_context(ast)
        
        try:
            content = self.render_template('CMakeLists.txt.jinja2', context)
            cmake_path = self.get_output_path('CMakeLists.txt')
            return self.write_file(cmake_path, content)
        except Exception as e:
            print(f"Template error for CMakeLists.txt: {e}")
            # Fallback to simple CMakeLists.txt
            content = self._generate_fallback_cmake(ast)
            cmake_path = self.get_output_path('CMakeLists.txt')
            return self.write_file(cmake_path, content)
    
    def _generate_package_xml(self, ast: RoboDSLAST) -> Path:
        """Generate package.xml file."""
        context = self._prepare_package_xml_context(ast)
        
        try:
            content = self.render_template('package.xml.jinja2', context)
            package_xml_path = self.get_output_path('package.xml')
            return self.write_file(package_xml_path, content)
        except Exception as e:
            print(f"Template error for package.xml: {e}")
            # Fallback to simple package.xml
            content = self._generate_fallback_package_xml(ast)
            package_xml_path = self.get_output_path('package.xml')
            return self.write_file(package_xml_path, content)
    
    def _generate_build_config(self, ast: RoboDSLAST) -> Path:
        """Generate build configuration file."""
        context = self._prepare_build_config_context(ast)
        
        content = f"""# Build configuration for {context['package_name']}
# Generated by RoboDSL

# Build type
set(CMAKE_BUILD_TYPE Release)

# Compiler flags
set(CMAKE_CXX_FLAGS_RELEASE "-O3 -DNDEBUG")
set(CMAKE_CXX_FLAGS_DEBUG "-g -O0 -DDEBUG")

# CUDA configuration
"""
        
        if context['has_cuda']:
            content += f"""set(CMAKE_CUDA_ARCHITECTURES {context['cuda_arch']})
set(CMAKE_CUDA_STANDARD {context['cuda_std']})
set(CMAKE_CUDA_FLAGS_RELEASE "-O3 -DNDEBUG")
set(CMAKE_CUDA_FLAGS_DEBUG "-g -O0 -DDEBUG")
"""
        
        content += f"""
# Testing configuration
set(BUILD_TESTING ON)
set(ENABLE_TESTING ON)

# Documentation
set(BUILD_DOCS ON)

# Install configuration
set(CMAKE_INSTALL_PREFIX "/opt/ros/humble")
"""
        
        config_path = self.get_output_path('build_config.cmake')
        return self.write_file(config_path, content)
    
    def _prepare_cmake_context(self, ast: RoboDSLAST) -> Dict[str, Any]:
        """Prepare context for CMake template rendering."""
        # Collect all dependencies
        dependencies = set()
        message_dependencies = set()
        cuda_dependencies = set()
        test_dependencies = set()
        
        # Check if we have any CUDA kernels
        has_cuda_kernels = bool(ast.cuda_kernels and ast.cuda_kernels.kernels)
        
        # Check nodes for CUDA kernels
        for node in ast.nodes:
            if node.content.cuda_kernels:
                has_cuda_kernels = True
        
        # Add ROS2 dependencies
        dependencies.update([
            'rclcpp',
            'std_msgs',
            'geometry_msgs'
        ])
        
        # Add lifecycle dependencies if any node is lifecycle
        for node in ast.nodes:
            if node.content.lifecycle:
                dependencies.add('rclcpp_lifecycle')
                break
        
        # Add CUDA dependencies if needed
        if has_cuda_kernels:
            cuda_dependencies.update([
                'CUDA',
                'cuda_runtime',
                'cudart'
            ])
        
        # Add test dependencies
        test_dependencies.update([
            'ament_lint_auto',
            'ament_lint_common',
            'ament_cmake_gtest',
            'ament_cmake_pytest'
        ])
        
        # Collect message dependencies from publishers/subscribers
        for node in ast.nodes:
            for pub in node.content.publishers:
                if '.' in pub.msg_type:
                    package = pub.msg_type.split('.')[0]
                    message_dependencies.add(package)
                else:
                    message_dependencies.add('std_msgs')
            
            for sub in node.content.subscribers:
                if '.' in sub.msg_type:
                    package = sub.msg_type.split('.')[0]
                    message_dependencies.add(package)
                else:
                    message_dependencies.add('std_msgs')
            
            for srv in node.content.services:
                if '.' in srv.srv_type:
                    package = srv.srv_type.split('.')[0]
                    message_dependencies.add(package)
                else:
                    message_dependencies.add('std_srvs')
            
            for action in node.content.actions:
                if '.' in action.action_type:
                    package = action.action_type.split('.')[0]
                    message_dependencies.add(package)
                else:
                    message_dependencies.add('std_msgs')
        
        # Prepare source files
        cpp_sources = []
        cuda_sources = []
        python_sources = []
        test_sources = []
        header_files = []
        
        # Add C++ node sources
        for node in ast.nodes:
            cpp_sources.append(f'src/{node.name}_node.cpp')
            header_files.append(f'include/{node.name}_node.hpp')
        
        # Add CUDA kernel sources
        if ast.cuda_kernels:
            for kernel in ast.cuda_kernels.kernels:
                cuda_sources.append(f'src/{kernel.name}_kernel.cu')
                header_files.append(f'include/{kernel.name}_kernel.cuh')
        
        # Add Python sources
        for node in ast.nodes:
            python_sources.append(f'robodsl/{node.name}_node.py')
        
        # Add test sources
        for node in ast.nodes:
            test_sources.append(f'tests/test_{node.name}_node.cpp')
        
        # Determine package name from AST or use default
        package_name = getattr(ast, 'package_name', 'robodsl_package')
        
        # Determine build configurations
        build_configs = ['Release', 'Debug', 'RelWithDebInfo', 'MinSizeRel']
        
        return {
            'package_name': package_name,
            'version': '0.1.0',
            'description': 'Generated ROS2 package from RoboDSL',
            'maintainer': 'robodsl',
            'maintainer_email': 'robodsl@example.com',
            'license': 'Apache-2.0',
            'dependencies': sorted(list(dependencies)),
            'message_dependencies': sorted(list(message_dependencies)),
            'cuda_dependencies': sorted(list(cuda_dependencies)),
            'test_dependencies': sorted(list(test_dependencies)),
            'has_cuda': has_cuda_kernels,
            'cpp_sources': cpp_sources,
            'cuda_sources': cuda_sources,
            'python_sources': python_sources,
            'test_sources': test_sources,
            'header_files': header_files,
            'executables': [f'{node.name}_node' for node in ast.nodes],
            'include_dirs': ['include'],
            'cuda_arch': '60 70 75 80 86',  # Common CUDA architectures
            'cuda_std': 'c++14',
            'build_configs': build_configs,
            'cmake_minimum_version': '3.8',
            'cxx_standard': 'c++14'
        }
    
    def _prepare_package_xml_context(self, ast: RoboDSLAST) -> Dict[str, Any]:
        """Prepare context for package.xml template rendering."""
        context = self._prepare_cmake_context(ast)
        
        # Add export dependencies
        export_dependencies = [
            'ament_cmake',
            'rclcpp',
            'std_msgs'
        ]
        
        if context['has_cuda']:
            export_dependencies.append('cuda')
        
        context['export_dependencies'] = export_dependencies
        
        return context
    
    def _prepare_build_config_context(self, ast: RoboDSLAST) -> Dict[str, Any]:
        """Prepare context for build configuration."""
        return self._prepare_cmake_context(ast)
    
    def _generate_fallback_cmake(self, ast: RoboDSLAST) -> str:
        """Generate a fallback CMakeLists.txt if template fails."""
        package_name = getattr(ast, 'package_name', 'robodsl_package')
        
        # Basic CMakeLists.txt content
        content = f"""cmake_minimum_required(VERSION 3.8)
project({package_name})

if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  add_compile_options(-Wall -Wextra -Wpedantic)
endif()

# Find dependencies
find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(std_msgs REQUIRED)

# Include directories
include_directories(include)

# Create executables
"""
        
        # Add executables for each node
        for node in ast.nodes:
            content += f"""add_executable({node.name}_node src/{node.name}_node.cpp)
ament_target_dependencies({node.name}_node rclcpp std_msgs)
"""
        
        # Add install targets
        content += """
# Install targets
install(TARGETS
"""
        for node in ast.nodes:
            content += f"  {node.name}_node\n"
        
        content += """  DESTINATION lib/${PROJECT_NAME}
)

# Install Python modules
install(DIRECTORY
  robodsl
  DESTINATION lib/python3/dist-packages/
)

# Install launch files
install(DIRECTORY
  launch
  DESTINATION share/${PROJECT_NAME}/
)

if(BUILD_TESTING)
  find_package(ament_lint_auto REQUIRED)
  ament_lint_auto_find_test_dependencies()
endif()

ament_package()
"""
        
        return content
    
    def _generate_fallback_package_xml(self, ast: RoboDSLAST) -> str:
        """Generate a fallback package.xml if template fails."""
        package_name = getattr(ast, 'package_name', 'robodsl_package')
        
        # Basic package.xml content
        content = f"""<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>{package_name}</name>
  <version>0.1.0</version>
  <description>Generated ROS2 package from RoboDSL</description>
  <maintainer email="robodsl@example.com">robodsl</maintainer>
  <license>Apache-2.0</license>

  <buildtool_depend>ament_cmake</buildtool_depend>
  <buildtool_depend>ament_cmake_python</buildtool_depend>

  <depend>rclcpp</depend>
  <depend>std_msgs</depend>
  <depend>geometry_msgs</depend>

  <test_depend>ament_lint_auto</test_depend>
  <test_depend>ament_lint_common</test_depend>

  <export>
    <build_type>ament_cmake</build_type>
  </export>
</package>
"""
        
        return content 